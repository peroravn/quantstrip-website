{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to Quantstrip Docs","text":"<ul> <li> <p> Getting started</p> <p>Learn the basics. Install the system and start automating your trading algorithms.</p> <p> Basic Concepts</p> </li> <li> <p> Take a tour</p> <p>Take a look at the apps and tools at your disposal.</p> <p> Dashboard apps</p> </li> <li> <p> Strategies</p> <p>Learn more about how to implement automated trading strategies by studying the code examples.</p> <p> Strategy examples</p> </li> <li> <p> Broker connections</p> <p>Use the collection of connectivity resources to connect to your preferred broker </p> <p> Broker integration</p> </li> </ul>"},{"location":"API/database.html","title":"Database Handler","text":""},{"location":"API/database.html#db_handler","title":"<code>db_handler</code>","text":"<p>The <code>db_handler</code> is a thread-safe singleton that manages all database operations for the Quantstrip trading system. It uses connection pooling for efficient concurrent access and implements the singleton pattern to ensure only one database handler exists per application instance.</p> <p>Key Features</p> <ul> <li>Thread-safe operations with connection pooling</li> <li>Singleton pattern for shared database access</li> <li>Time-based order ID generation</li> <li>Canonical order and execution tracking with metadata support</li> <li>Event-based position tracking (position_event and strategy_event)</li> <li>External position reconciliation</li> <li>Comprehensive reporting system with email account management</li> </ul>"},{"location":"API/database.html#initialization-and-connection","title":"Initialization and Connection","text":"<p>Import <code>db_handler</code> from <code>quantstrip</code> <pre><code>from quantstrip import db_handler as db\n</code></pre></p> <p>get_connection()</p> <p>Context manager that retrieves a connection from the pool. This is the primary way to interact with the database directly.</p> <p>Returns: Database connection object</p> <p>Example: <pre><code>with db.get_connection() as conn:\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT * FROM broker\")\n    results = cursor.fetchall()\n</code></pre></p> <p>Tip</p> <p>The connection pool automatically manages connection lifecycle, returning connections to the pool when done or creating temporary connections if the pool is exhausted.</p>"},{"location":"API/database.html#running-an-sql-query","title":"Running an SQL Query","text":"<p>run_query(sql_str, params=())</p> <p>Executes a SELECT query and returns results as a pandas DataFrame. This is the recommended way to retrieve data from the database.</p> <p>Parameters:</p> Parameter Type Description <code>sql_str</code> <code>str</code> SQL query string <code>params</code> <code>tuple</code> Query parameters for safe parameterized queries <p>Returns: <code>pandas.DataFrame</code> with query results</p> <p>Example: <pre><code>df = db.run_query(\n    \"SELECT * FROM execution WHERE order_id = ?\", \n    (12345,)\n)\n</code></pre></p>"},{"location":"API/database.html#order-id-generation","title":"Order ID Generation","text":"<p>next_order_id() Generates a strictly monotonic increasing order ID based on seconds since epoch (2020-01-01). This method is both thread-safe and process-safe.</p> <p>Returns: <code>int</code> - Order ID (9 digits maximum)</p> <p>Example: <pre><code>order_id = db.next_order_id()\nprint(f\"New order: {order_id}\")  # e.g., 163847291\n</code></pre></p> <p>How It Works</p> <ol> <li>Calculates seconds since epoch (2020-01-01)</li> <li>Retrieves last used ID from database</li> <li>Ensures new ID is strictly greater than last ID</li> <li>Persists new ID to database for process safety</li> <li>Handles edge cases like same-second calls or manual orders</li> <li>Raises OverflowError if ID exceeds 9 digits</li> </ol>"},{"location":"API/database.html#order-management","title":"Order Management","text":"<p>insert_order(order_id, strategy_id, broker_id, account, symbol, side, order_type, total_quantity, limit_price=None, stop_price=None, trail_amount=None, instrument_type=None, parent_order_id=None, client_reference=None, external_order_id=None, metadata=None) Insert a canonical order record. The order_id is the Quantstrip-generated time-based ID from <code>next_order_id()</code>.</p> <p>Parameters:</p> Parameter Type Description <code>order_id</code> <code>int</code> Quantstrip order ID (from next_order_id()) <code>strategy_id</code> <code>int</code> Strategy placing the order <code>broker_id</code> <code>int</code> Broker to execute the order <code>account</code> <code>str</code> Trading account identifier <code>symbol</code> <code>str</code> Trading symbol <code>side</code> <code>str</code> 'BUY' or 'SELL' <code>order_type</code> <code>str</code> MKT, LMT, STOP, STOP_LIMIT, IOC, FOK, TRAILING, etc. <code>total_quantity</code> <code>float</code> Number of shares/contracts (always positive) <code>limit_price</code> <code>float</code> Limit price (for limit orders) <code>stop_price</code> <code>float</code> Stop price (for stop orders) <code>trail_amount</code> <code>float</code> Trail amount (for trailing stops) <code>instrument_type</code> <code>str</code> STOCK, CRYPTO, FUTURE, OPTION <code>parent_order_id</code> <code>int</code> Parent order ID (for bracket orders) <code>client_reference</code> <code>str</code> Client-provided reference/orderRef <code>external_order_id</code> <code>str</code> Broker's order ID (IB orderId, Binance orderId) <code>metadata</code> <code>dict</code> Extra broker-specific fields (stored as JSON) <p>Returns: <code>int</code> - order_id</p> <p>Example: <pre><code># Generate order ID\norder_id = db.next_order_id()\n\n# Create order record\ndb.insert_order(\n    order_id=order_id,\n    strategy_id=1,\n    broker_id=1,\n    account=\"U1234567\",\n    symbol=\"AAPL\",\n    side=\"BUY\",\n    order_type=\"LMT\",\n    total_quantity=100,\n    limit_price=150.50,\n    instrument_type=\"STOCK\",\n    client_reference=\"tech_basket_entry\",\n    metadata={\n        \"signal_type\": \"momentum\",\n        \"entry_date\": \"2025-01-17\"\n    }\n)\n</code></pre></p> <p>update_order_external_id(order_id, external_order_id) Update the broker-assigned permanent order ID. This links the Quantstrip order_id with the broker's order ID.</p> <p>Parameters:</p> Parameter Type Description <code>order_id</code> <code>int</code> Quantstrip order ID <code>external_order_id</code> <code>str</code> Broker's permanent order ID <p>Example: <pre><code># After placing order with broker\ndb.update_order_external_id(order_id=order_id, external_order_id=\"1234567890\")\n</code></pre></p> <p>get_order(order_id=None, strategy_id=None, symbol=None) Get order records with flexible filtering.</p> <p>Parameters:</p> Parameter Type Description <code>order_id</code> <code>int</code> Filter by order ID (optional) <code>strategy_id</code> <code>int</code> Filter by strategy (optional) <code>symbol</code> <code>str</code> Filter by symbol (optional) <p>Returns: <code>pandas.DataFrame</code> with order details</p> <p>Example: <pre><code># Get specific order\norder = db.get_order(order_id=163847291)\n\n# Get all orders for a strategy and symbol\norders = db.get_order(strategy_id=1, symbol=\"AAPL\")\n\n# Get all orders for a strategy\nstrategy_orders = db.get_order(strategy_id=1)\n\n# Get all orders\nall_orders = db.get_order()\n</code></pre></p>"},{"location":"API/database.html#order-status-tracking","title":"Order Status Tracking","text":"<p>insert_order_status(order_id, status, filled_quantity=None, remaining_quantity=None, avg_fill_price=None, last_fill_price=None, external_order_id=None, client_reference=None, parent_order_id=None, reason_held=None, cap_price=None, metadata=None, event_time=None) Insert a new order status event. This does NOT update previous rows - every broker status transition becomes a new row for complete audit trail.</p> <p>Parameters:</p> Parameter Type Description <code>order_id</code> <code>int</code> Order ID (foreign key to orders table) <code>status</code> <code>str</code> NEW, SUBMITTED, PARTIALLY_FILLED, FILLED, CANCELLED, REJECTED, etc. <code>filled_quantity</code> <code>float</code> Total filled so far <code>remaining_quantity</code> <code>float</code> Remaining amount <code>avg_fill_price</code> <code>float</code> Weighted avg fill price so far <code>last_fill_price</code> <code>float</code> Price of the last fill event <code>external_order_id</code> <code>str</code> Broker's order ID <code>client_reference</code> <code>str</code> Client-provided reference <code>parent_order_id</code> <code>int</code> For brackets/OCO/etc. <code>reason_held</code> <code>str</code> IBKR whyHeld (e.g., \"locate\") <code>cap_price</code> <code>float</code> IBKR market cap price or Binance price cap <code>metadata</code> <code>dict</code> Broker-specific extras (stored as JSON) <code>event_time</code> <code>str</code> Broker timestamp (else defaults to now) <p>Example: <pre><code># When orderStatus callback is received\ndb.insert_order_status(\n    order_id=order_id,\n    status=\"SUBMITTED\",\n    filled_quantity=0,\n    remaining_quantity=100\n)\n\n# When order partially fills\ndb.insert_order_status(\n    order_id=order_id,\n    status=\"PARTIALLY_FILLED\",\n    filled_quantity=50,\n    remaining_quantity=50,\n    avg_fill_price=150.48,\n    last_fill_price=150.48\n)\n\n# When order completely fills\ndb.insert_order_status(\n    order_id=order_id,\n    status=\"FILLED\",\n    filled_quantity=100,\n    remaining_quantity=0,\n    avg_fill_price=150.48,\n    last_fill_price=150.49\n)\n</code></pre></p> <p>get_order_status(order_id=None) Get all order status events, newest first. Returns complete history of status changes.</p> <p>Parameters:</p> Parameter Type Description <code>order_id</code> <code>int</code> Filter by order ID (optional) <p>Returns: <code>pandas.DataFrame</code> with order status details</p> <p>Example: <pre><code># Get status history for specific order\nstatus_history = db.get_order_status(order_id=163847291)\n\n# Get all order statuses\nall_statuses = db.get_order_status()\n</code></pre></p> <p>get_current_order_status(order_id) Get only the most recent status for an order.</p> <p>Parameters:</p> Parameter Type Description <code>order_id</code> <code>int</code> Order ID to query <p>Returns: Single row (dict-like) with latest status, or None</p> <p>Example: <pre><code>current = db.get_current_order_status(order_id=163847291)\nif current:\n    print(f\"Current status: {current['status']}\")\n</code></pre></p>"},{"location":"API/database.html#strategy-event-tracking","title":"Strategy Event Tracking","text":"<p>Strategy events track intended position changes before they are executed. Used for planning and reconciliation.</p> <p>insert_strategy_event(order_id, position, event_type, group_label=None, status=\"PENDING\", metadata=None) Insert a canonical strategy event snapshot.</p> <p>Parameters:</p> Parameter Type Description <code>order_id</code> <code>int</code> Associated order ID (unique constraint) <code>position</code> <code>float</code> Intended position size <code>event_type</code> <code>str</code> OPEN, CLOSE, OPEN/CLOSE, FLIP, PARTIAL_CLOSE, etc. <code>group_label</code> <code>str</code> Optional label for grouping related events <code>status</code> <code>str</code> PENDING, EXECUTED, FAILED <code>metadata</code> <code>dict</code> Additional event data (stored as JSON) <p>Example: <pre><code>db.insert_strategy_event(\n    order_id=order_id,\n    position=100,\n    event_type=\"OPEN\",\n    group_label=\"tech_basket\",\n    status=\"PENDING\",\n    metadata={\"signal\": \"momentum_crossover\"}\n)\n</code></pre></p> <p>get_last_strategy_event(strategy_id, symbol) Get the most recent strategy event for a strategy-symbol pair.</p> <p>Parameters:</p> Parameter Type Description <code>strategy_id</code> <code>int</code> Strategy ID <code>symbol</code> <code>str</code> Trading symbol <p>Returns: Dictionary with event details, or None</p> <p>Example: <pre><code>last_event = db.get_last_strategy_event(strategy_id=1, symbol=\"AAPL\")\nif last_event:\n    print(f\"Last event: {last_event['event_type']} at {last_event['event_time']}\")\n</code></pre></p>"},{"location":"API/database.html#position-event-tracking","title":"Position Event Tracking","text":"<p>Position events track actual executed position changes with execution details. This is the realized position history.</p> <p>insert_position_event(event_time, strategy_id, broker_id, exec_id, order_id, symbol, position, avg_price, trade_quantity, trade_price, event_type, group_label=None, metadata=None) Insert a canonical position event snapshot.</p> <p>Parameters:</p> Parameter Type Description <code>event_time</code> <code>str</code> Event timestamp <code>strategy_id</code> <code>int</code> Strategy ID <code>broker_id</code> <code>int</code> Broker ID <code>exec_id</code> <code>str</code> Links to execution.exec_id (unique) <code>order_id</code> <code>int</code> Order ID <code>symbol</code> <code>str</code> Trading symbol <code>position</code> <code>float</code> New position size after event <code>avg_price</code> <code>float</code> Cost basis after event <code>trade_quantity</code> <code>float</code> Signed qty: +buy, -sell <code>trade_price</code> <code>float</code> Execution price <code>event_type</code> <code>str</code> OPEN, CLOSE, OPEN/CLOSE, FLIP, PARTIAL_CLOSE, etc. <code>group_label</code> <code>str</code> Optional grouping label <code>metadata</code> <code>dict</code> Additional event data (stored as JSON) <p>Example: <pre><code>db.insert_position_event(\n    event_time=\"2025-01-17 14:30:45\",\n    strategy_id=1,\n    broker_id=1,\n    exec_id=\"0001f4e8.65a1b2c3.01.01\",\n    order_id=order_id,\n    symbol=\"AAPL\",\n    position=100,\n    avg_price=150.25,\n    trade_quantity=100,\n    trade_price=150.25,\n    event_type=\"OPEN\",\n    group_label=\"tech_basket\"\n)\n</code></pre></p> <p>get_last_position_event(strategy_id, symbol) Get the most recent position event for a strategy-symbol pair.</p> <p>Parameters:</p> Parameter Type Description <code>strategy_id</code> <code>int</code> Strategy ID <code>symbol</code> <code>str</code> Trading symbol <p>Returns: Dictionary with event details, or None</p> <p>Example: <pre><code>last_position = db.get_last_position_event(strategy_id=1, symbol=\"AAPL\")\nif last_position:\n    print(f\"Current position: {last_position['position']} @ {last_position['avg_price']}\")\n</code></pre></p>"},{"location":"API/database.html#external-position-management","title":"External Position Management","text":"<p>External positions track actual positions reported by your broker. This table stores the raw position data from the broker API for reconciliation.</p> <p>insert_position_external(account, contract_id, position, avg_cost, info_1=\"\", info_2=\"\", info_3=\"\", info_4=\"\", info_5=\"\") Records a position update from the broker. Typically called when receiving position callbacks from broker API.</p> <p>Parameters:</p> Parameter Type Description <code>account</code> <code>str</code> Broker account number <code>contract_id</code> <code>int</code> Broker contract ID <code>position</code> <code>float</code> Current position size <code>avg_cost</code> <code>float</code> Average cost basis <code>info_1</code> to <code>info_5</code> <code>str</code> Custom metadata fields <p>Example: <pre><code># When receiving broker position callback\ndb.insert_position_external(\n    account=\"U1234567\",\n    contract_id=12345,\n    position=100,\n    avg_cost=150.25,\n    info_1=\"AAPL\",\n    info_2=\"STOCK\"\n)\n</code></pre></p> <p>get_positions_external(account=None) Retrieves external positions, optionally filtered by account.</p> <p>Parameters:</p> Parameter Type Description <code>account</code> <code>str</code> Filter by specific account (optional) <p>Returns: <code>pandas.DataFrame</code> with external positions</p> <p>Example: <pre><code># Get all external positions\nall_ext_positions = db.get_positions_external()\n\n# Get positions for specific account\naccount_positions = db.get_positions_external(account=\"U1234567\")\n</code></pre></p>"},{"location":"API/database.html#execution-tracking","title":"Execution Tracking","text":"<p>insert_execution(exec_id, order_id, strategy_id, broker_id, symbol, instrument_type, contract_id, side, quantity, price, exec_time, exchange=None, liquidity_flag=None, order_type=None, cum_qty=None, avg_price=None, is_liquidation=None, external_order_id=None, external_exec_id=None, metadata=None) Records a trade execution with full details. This should be called from execution callbacks.</p> <p>Parameters:</p> Parameter Type Description <code>exec_id</code> <code>str</code> Unique execution ID <code>order_id</code> <code>int</code> Quantstrip order ID (foreign key) <code>strategy_id</code> <code>int</code> Strategy ID <code>broker_id</code> <code>int</code> Broker ID <code>symbol</code> <code>str</code> Trading symbol (e.g., SPY, AAPL, BTCUSDT) <code>instrument_type</code> <code>str</code> STOCK, CRYPTO, FUTURE, OPTION <code>contract_id</code> <code>str</code> IB conId, Binance alt ID <code>side</code> <code>str</code> BUY or SELL <code>quantity</code> <code>float</code> Execution quantity (always positive) <code>price</code> <code>float</code> Execution price <code>exec_time</code> <code>str</code> Execution timestamp <code>exchange</code> <code>str</code> NYSE, ARCA, BINANCE, etc. <code>liquidity_flag</code> <code>str</code> MAKER, TAKER, etc. <code>order_type</code> <code>str</code> MKT, LMT, IOC, FOK <code>cum_qty</code> <code>float</code> Cumulative filled quantity <code>avg_price</code> <code>float</code> Broker-reported average price <code>is_liquidation</code> <code>int</code> Forced liquidation flag (0 or 1) <code>external_order_id</code> <code>str</code> Broker's order ID <code>external_exec_id</code> <code>str</code> Broker's execution ID <code>metadata</code> <code>dict</code> Additional data (stored as JSON) <p>Example: <pre><code># When receiving broker execDetails callback\ndb.insert_execution(\n    exec_id=\"0001f4e8.65a1b2c3.01.01\",\n    order_id=order_id,\n    strategy_id=1,\n    broker_id=1,\n    symbol=\"AAPL\",\n    instrument_type=\"STOCK\",\n    contract_id=\"265598\",\n    side=\"BUY\",\n    quantity=100,\n    price=150.25,\n    exec_time=\"2025-01-17 14:30:45\",\n    exchange=\"SMART\",\n    liquidity_flag=\"TAKER\",\n    order_type=\"LMT\",\n    cum_qty=100,\n    avg_price=150.25,\n    is_liquidation=0,\n    external_order_id=\"1234567890\",\n    external_exec_id=\"0001f4e8.65a1b2c3.01.01\"\n)\n</code></pre></p> <p>get_executions(order_id=None, exec_id=None) Retrieves execution records with optional filtering.</p> <p>Parameters:</p> Parameter Type Description <code>order_id</code> <code>int</code> Filter by order ID (optional) <code>exec_id</code> <code>str</code> Filter by execution ID (optional) <p>Returns: <code>pandas.DataFrame</code> with execution details</p> <p>Example: <pre><code># Get all executions for an order\norder_execs = db.get_executions(order_id=163847291)\n\n# Get specific execution\nspecific_exec = db.get_executions(exec_id=\"0001f4e8.65a1b2c3.01.01\")\n\n# Get all executions\nall_execs = db.get_executions()\n</code></pre></p>"},{"location":"API/database.html#commission-tracking","title":"Commission Tracking","text":"<p>insert_commission(exec_id, amount, currency, fee_type, realized_pnl=None, metadata=None) Records commission and fees for a specific execution. Called when receiving broker commission reports.</p> <p>Parameters:</p> Parameter Type Description <code>exec_id</code> <code>str</code> Links to execution record <code>amount</code> <code>float</code> Commission/fee amount <code>currency</code> <code>str</code> Commission currency (e.g., \"USD\") <code>fee_type</code> <code>str</code> Commission type identifier <code>realized_pnl</code> <code>float</code> Realized profit/loss <code>metadata</code> <code>dict</code> Additional data (stored as JSON) <p>Example: <pre><code>db.insert_commission(\n    exec_id=\"0001f4e8.65a1b2c3.01.01\",\n    amount=1.25,\n    currency=\"USD\",\n    fee_type=\"commission\",\n    realized_pnl=523.50,\n    metadata={\"rate\": \"tiered\"}\n)\n</code></pre></p>"},{"location":"API/database.html#broker-management","title":"Broker Management","text":"<p>insert_broker(name, full_name) Adds a new broker to the system.</p> <p>Parameters:</p> Parameter Type Description <code>name</code> <code>str</code> Short broker identifier (e.g., \"IBKR\") <code>full_name</code> <code>str</code> Full broker name <p>Example: <pre><code>db.insert_broker(\n    name=\"IBKR\",\n    full_name=\"Interactive Brokers\"\n)\n</code></pre></p> <p>update_broker(broker_id, name, full_name) Updates an existing broker's details.</p> <p>Example: <pre><code>db.update_broker(\n    broker_id=1,\n    name=\"IBKR\",\n    full_name=\"Interactive Brokers LLC\"\n)\n</code></pre></p> <p>delete_broker(broker_id) Removes a broker from the system.</p> <p>Example: <pre><code>db.delete_broker(broker_id=2)\n</code></pre></p> <p>get_brokers() Returns all registered brokers.</p> <p>Returns: <code>pandas.DataFrame</code> with broker_id, name, and full_name</p> <p>Example: <pre><code>brokers = db.get_brokers()\nprint(brokers)\n</code></pre></p> <p>get_broker_id(name) Looks up a broker's ID by name.</p> <p>Returns: <code>int</code> or <code>None</code></p> <p>Example: <pre><code>broker_id = db.get_broker_id(\"IBKR\")\n</code></pre></p>"},{"location":"API/database.html#strategy-management","title":"Strategy Management","text":"<p>get_strategies() Returns all registered trading strategies.</p> <p>Returns: <code>pandas.DataFrame</code> with strategy_id, name, and description</p> <p>Example: <pre><code>strategies = db.get_strategies()\nfor idx, row in strategies.iterrows():\n    print(f\"{row['name']}: {row['description']}\")\n</code></pre></p> <p>get_strategy_id(name) Looks up a strategy's ID by name.</p> <p>Returns: <code>int</code> or <code>None</code></p> <p>Example: <pre><code>strategy_id = db.get_strategy_id(\"momentum_v2\")\n</code></pre></p>"},{"location":"API/database.html#reporting-system","title":"Reporting System","text":"<p>The reporting system provides a hierarchical structure for generating trade reports: Report \u2192 Sections \u2192 Items.</p> <p>insert_report(name, date, status, report_type, recipients) Creates a new report container. This is the top-level object for organizing report content.</p> <p>Parameters:</p> Parameter Type Description <code>name</code> <code>str</code> Report title <code>date</code> <code>str</code> Report date <code>status</code> <code>str</code> Status (e.g., \"draft\", \"final\", \"sent\") <code>report_type</code> <code>str</code> Report type (e.g., \"daily\", \"monthly\") <code>recipients</code> <code>str</code> Comma-separated recipient list <p>Returns: <code>int</code> - report_id</p> <p>Example: <pre><code>report_id = db.insert_report(\n    name=\"Daily Trading Report - Jan 17\",\n    date=\"2025-01-17\",\n    status=\"draft\",\n    report_type=\"daily\",\n    recipients=\"trader@example.com,manager@example.com\"\n)\n</code></pre></p> <p>update_report(report_id, name=None, date=None, status=None, report_type=None, recipients=None) Updates report fields. Only provided parameters are updated.</p> <p>Example: <pre><code># Mark report as final\ndb.update_report(report_id=5, status=\"final\")\n\n# Update multiple fields\ndb.update_report(\n    report_id=5,\n    status=\"sent\",\n    recipients=\"trader@example.com,compliance@example.com\"\n)\n</code></pre></p> <p>get_reports(report_id=None) Retrieves reports, optionally filtered by ID. Results are ordered by date (newest first).</p> <p>Example: <pre><code># Get all reports\nall_reports = db.get_reports()\n\n# Get specific report\nreport = db.get_reports(report_id=5)\n</code></pre></p> <p>insert_report_section(report_id, name, section_type) Adds a section to a report. Sections organize content by category (e.g., \"Summary\", \"Risk Analysis\", \"Trade List\").</p> <p>Parameters:</p> Parameter Type Description <code>report_id</code> <code>int</code> Parent report ID <code>name</code> <code>str</code> Section title <code>section_type</code> <code>str</code> Section type identifier <p>Returns: <code>int</code> - section_id</p> <p>Example: <pre><code>summary_section = db.insert_report_section(\n    report_id=5,\n    name=\"Executive Summary\",\n    section_type=\"summary\"\n)\n\ntrades_section = db.insert_report_section(\n    report_id=5,\n    name=\"Today's Trades\",\n    section_type=\"trade_list\"\n)\n</code></pre></p> <p>get_report_sections(report_id) Retrieves all sections for a report, ordered by section_id.</p> <p>Example: <pre><code>sections = db.get_report_sections(report_id=5)\nfor idx, section in sections.iterrows():\n    print(f\"Section: {section['name']}\")\n</code></pre></p> <p>insert_report_item(section_id, text) Adds content to a report section. Items contain the actual text/data.</p> <p>Parameters:</p> Parameter Type Description <code>section_id</code> <code>int</code> Parent section ID <code>text</code> <code>str</code> Content text (can be markdown, JSON, etc.) <p>Returns: <code>int</code> - item_id</p> <p>Example: <pre><code>db.insert_report_item(\n    section_id=summary_section,\n    text=\"Traded 5 symbols today with 100% fill rate.\"\n)\n\ndb.insert_report_item(\n    section_id=trades_section,\n    text=\"AAPL: BUY 100 @ $150.25\"\n)\n</code></pre></p> <p>get_report_items(section_id) Retrieves all items for a section, ordered by item_id.</p> <p>Example: <pre><code>items = db.get_report_items(section_id=summary_section)\nfor idx, item in items.iterrows():\n    print(item['text'])\n</code></pre></p>"},{"location":"API/database.html#email-account-management","title":"Email Account Management","text":"<p>The email account system manages SMTP configurations for sending reports and notifications.</p> <p>get_all_email_accounts() Get all configured email accounts.</p> <p>Returns: <code>pandas.DataFrame</code> with all email account details</p> <p>Example: <pre><code>accounts = db.get_all_email_accounts()\nfor idx, account in accounts.iterrows():\n    print(f\"{account['name']}: {account['from_address']}\")\n</code></pre></p> <p>get_email_account_by_id(email_account_id) Get a specific email account by ID.</p> <p>Parameters:</p> Parameter Type Description <code>email_account_id</code> <code>int</code> Email account ID <p>Returns: Dictionary with account details, or None</p> <p>Example: <pre><code>account = db.get_email_account_by_id(1)\nif account:\n    print(f\"SMTP: {account['smtp_server']}:{account['smtp_port']}\")\n</code></pre></p> <p>get_email_account_by_name(name) Get a specific email account by name.</p> <p>Parameters:</p> Parameter Type Description <code>name</code> <code>str</code> Email account name <p>Returns: Dictionary with account details, or None</p> <p>Example: <pre><code>account = db.get_email_account_by_name(\"Gmail Trading\")\n</code></pre></p> <p>get_default_email_account() Get the default email account.</p> <p>Returns: Dictionary with account details, or None</p> <p>Example: <pre><code>default_account = db.get_default_email_account()\nif default_account:\n    print(f\"Default: {default_account['from_address']}\")\n</code></pre></p>"},{"location":"API/database.html#complete-report-example","title":"Complete Report Example","text":"<pre><code># Create a daily report\nreport_id = db.insert_report(\n    name=\"Daily Report - Jan 17, 2025\",\n    date=\"2025-01-17\",\n    status=\"draft\",\n    report_type=\"daily\",\n    recipients=\"team@example.com\"\n)\n\n# Add summary section\nsummary = db.insert_report_section(\n    report_id=report_id,\n    name=\"Executive Summary\",\n    section_type=\"summary\"\n)\n\ndb.insert_report_item(\n    section_id=summary,\n    text=\"Total P&amp;L: $1,234.56\"\n)\n\ndb.insert_report_item(\n    section_id=summary,\n    text=\"Win rate: 65%\"\n)\n\n# Add trades section\ntrades = db.insert_report_section(\n    report_id=report_id,\n    name=\"Executed Trades\",\n    section_type=\"trades\"\n)\n\n# Get executions for the day\nexecutions = db.get_executions()\nfor idx, exec in executions.iterrows():\n    db.insert_report_item(\n        section_id=trades,\n        text=f\"{exec['side']} {exec['quantity']} {exec['symbol']} @ ${exec['price']}\"\n    )\n\n# Finalize report\ndb.update_report(report_id=report_id, status=\"final\")\n</code></pre>"},{"location":"API/database.html#complete-order-workflow-example","title":"Complete Order Workflow Example","text":"<p>Here's a complete example showing the typical order lifecycle with all database operations:</p> <pre><code>from quantstrip import db_handler as db\n\n# 1. Generate order ID\norder_id = db.next_order_id()  # e.g., 163847291\n\n# 2. Create order record\ndb.insert_order(\n    order_id=order_id,\n    strategy_id=1,\n    broker_id=1,\n    account=\"U1234567\",\n    symbol=\"AAPL\",\n    side=\"BUY\",\n    order_type=\"LMT\",\n    total_quantity=100,\n    limit_price=150.50,\n    instrument_type=\"STOCK\",\n    client_reference=\"tech_basket_entry\",\n    metadata={\n        \"signal_type\": \"momentum\",\n        \"entry_date\": \"2025-01-17\"\n    }\n)\n\n# 3. Create strategy event (planned position change)\ndb.insert_strategy_event(\n    order_id=order_id,\n    position=100,\n    event_type=\"OPEN\",\n    group_label=\"tech_basket\",\n    status=\"PENDING\",\n    metadata={\"signal\": \"momentum_crossover\"}\n)\n\n# 4. After placing order with broker, update external_order_id\ndb.update_order_external_id(order_id=order_id, external_order_id=\"1234567890\")\n\n# 5. When orderStatus callback is received (order submitted)\ndb.insert_order_status(\n    order_id=order_id,\n    status=\"SUBMITTED\",\n    filled_quantity=0,\n    remaining_quantity=100,\n    external_order_id=\"1234567890\"\n)\n\n# 6. When order partially fills (orderStatus callback)\ndb.insert_order_status(\n    order_id=order_id,\n    status=\"PARTIALLY_FILLED\",\n    filled_quantity=50,\n    remaining_quantity=50,\n    avg_fill_price=150.48,\n    last_fill_price=150.48\n)\n\n# 7. When execDetails callback is received (first fill)\ndb.insert_execution(\n    exec_id=\"0001f4e8.65a1b2c3.01.01\",\n    order_id=order_id,\n    strategy_id=1,\n    broker_id=1,\n    symbol=\"AAPL\",\n    instrument_type=\"STOCK\",\n    contract_id=\"265598\",\n    side=\"BUY\",\n    quantity=50,\n    price=150.48,\n    exec_time=\"2025-01-17 14:30:45\",\n    exchange=\"SMART\",\n    liquidity_flag=\"TAKER\",\n    order_type=\"LMT\",\n    cum_qty=50,\n    avg_price=150.48,\n    external_order_id=\"1234567890\",\n    external_exec_id=\"0001f4e8.65a1b2c3.01.01\"\n)\n\n# 8. When commissionReport callback is received\ndb.insert_commission(\n    exec_id=\"0001f4e8.65a1b2c3.01.01\",\n    amount=0.50,\n    currency=\"USD\",\n    fee_type=\"commission\",\n    realized_pnl=0\n)\n\n# 9. Update position event (actual position change)\ndb.insert_position_event(\n    event_time=\"2025-01-17 14:30:45\",\n    strategy_id=1,\n    broker_id=1,\n    exec_id=\"0001f4e8.65a1b2c3.01.01\",\n    order_id=order_id,\n    symbol=\"AAPL\",\n    position=50,\n    avg_price=150.48,\n    trade_quantity=50,\n    trade_price=150.48,\n    event_type=\"OPEN\",\n    group_label=\"tech_basket\"\n)\n\n# 10. When order completely fills (orderStatus callback)\ndb.insert_order_status(\n    order_id=order_id,\n    status=\"FILLED\",\n    filled_quantity=100,\n    remaining_quantity=0,\n    avg_fill_price=150.485,\n    last_fill_price=150.49\n)\n\n# 11. Record second execution\ndb.insert_execution(\n    exec_id=\"0001f4e8.65a1b2c3.01.02\",\n    order_id=order_id,\n    strategy_id=1,\n    broker_id=1,\n    symbol=\"AAPL\",\n    instrument_type=\"STOCK\",\n    contract_id=\"265598\",\n    side=\"BUY\",\n    quantity=50,\n    price=150.49,\n    exec_time=\"2025-01-17 14:31:12\",\n    exchange=\"SMART\",\n    liquidity_flag=\"TAKER\",\n    order_type=\"LMT\",\n    cum_qty=100,\n    avg_price=150.485,\n    external_order_id=\"1234567890\",\n    external_exec_id=\"0001f4e8.65a1b2c3.01.02\"\n)\n\n# 12. Update final position event\ndb.insert_position_event(\n    event_time=\"2025-01-17 14:31:12\",\n    strategy_id=1,\n    broker_id=1,\n    exec_id=\"0001f4e8.65a1b2c3.01.02\",\n    order_id=order_id,\n    symbol=\"AAPL\",\n    position=100,\n    avg_price=150.485,\n    trade_quantity=50,\n    trade_price=150.49,\n    event_type=\"OPEN\",\n    group_label=\"tech_basket\"\n)\n\n# 13. Mark strategy event as executed\n# (Note: This would require an update method for strategy_event,\n#  which is not currently in the code but would be useful)\n\n# 14. Query current position\nlast_position = db.get_last_position_event(strategy_id=1, symbol=\"AAPL\")\nprint(f\"Current position: {last_position['position']} @ {last_position['avg_price']}\")\n</code></pre>"},{"location":"API/database.html#position-reconciliation-example","title":"Position Reconciliation Example","text":"<p>Compare internal positions (strategy events and position events) with external positions from broker:</p> <pre><code># Get internal position from position_event table\ninternal_position = db.get_last_position_event(strategy_id=1, symbol=\"AAPL\")\n\n# Get external position from broker\nexternal_positions = db.get_positions_external(account=\"U1234567\")\nexternal_aapl = external_positions[external_positions['info_1'] == 'AAPL']\n\n# Compare\nif internal_position:\n    internal_qty = internal_position['position']\n    internal_avg = internal_position['avg_price']\n\n    if not external_aapl.empty:\n        external_qty = external_aapl.iloc[0]['position']\n        external_avg = external_aapl.iloc[0]['avg_cost']\n\n        if abs(internal_qty - external_qty) &gt; 0.01:\n            print(f\"\u26a0\ufe0f  Position mismatch for AAPL!\")\n            print(f\"   Internal: {internal_qty} @ {internal_avg}\")\n            print(f\"   External: {external_qty} @ {external_avg}\")\n        else:\n            print(f\"\u2713 Positions reconciled: {internal_qty} shares\")\n</code></pre>"},{"location":"API/database.html#database-tables-reference","title":"Database Tables Reference","text":""},{"location":"API/database.html#core-trading-tables","title":"Core Trading Tables","text":"Table Purpose <code>orders</code> Canonical order records with Quantstrip order_id <code>order_status</code> Complete history of order status changes (append-only) <code>execution</code> Individual trade executions with full details <code>commission</code> Commission and fee records linked to executions <code>position_event</code> Actual realized position changes (linked to executions) <code>strategy_event</code> Planned position changes (intent before execution) <code>position_external</code> Raw broker-reported positions for reconciliation"},{"location":"API/database.html#reference-tables","title":"Reference Tables","text":"Table Purpose <code>broker</code> Registered brokers (IBKR, Binance, etc.) <code>strategy</code> Trading strategies <code>order_id_state</code> Order ID generation state (singleton record) <code>mtm_price</code> Mark-to-market prices for valuation"},{"location":"API/database.html#reporting-tables","title":"Reporting Tables","text":"Table Purpose <code>report</code> Report containers <code>report_section</code> Report sections within reports <code>report_item</code> Individual content items within sections <code>email_account</code> SMTP configurations for sending reports"},{"location":"API/database.html#key-design-patterns","title":"Key Design Patterns","text":""},{"location":"API/database.html#event-based-position-tracking","title":"Event-Based Position Tracking","text":"<p>The system uses two complementary position tracking mechanisms:</p> <ol> <li>Strategy Events (<code>strategy_event</code> table)</li> <li>Records intended position changes</li> <li>Created when strategy signals a trade</li> <li>Status: PENDING \u2192 EXECUTED/FAILED</li> <li> <p>Used for planning and verification</p> </li> <li> <p>Position Events (<code>position_event</code> table)</p> </li> <li>Records actual position changes</li> <li>Created when executions occur</li> <li>Linked to specific executions via <code>exec_id</code></li> <li>Provides complete audit trail of realized positions</li> </ol> <p>This dual-tracking allows you to: - Compare intended vs. actual positions - Track execution slippage - Identify failed orders - Maintain complete position history</p>"},{"location":"API/database.html#append-only-order-status","title":"Append-Only Order Status","text":"<p>The <code>order_status</code> table is append-only - every status change creates a new row rather than updating existing rows. This provides:</p> <ul> <li>Complete audit trail of order lifecycle</li> <li>Ability to analyze timing of status changes</li> <li>No data loss from updates</li> <li>Easy debugging of order issues</li> </ul> <p>Use <code>get_current_order_status()</code> to get the latest status, or <code>get_order_status()</code> to see complete history.</p>"},{"location":"API/database.html#json-metadata-storage","title":"JSON Metadata Storage","text":"<p>Many tables include a <code>metadata</code> field that stores arbitrary JSON data. This allows:</p> <ul> <li>Broker-specific fields without schema changes</li> <li>Custom strategy parameters</li> <li>Flexible data storage for evolving needs</li> <li>Easy addition of new fields</li> </ul> <p>Example: <pre><code>metadata = {\n    \"algo_name\": \"VWAP\",\n    \"urgency\": \"normal\",\n    \"broker_specific_field\": \"value\"\n}\n\ndb.insert_order(\n    order_id=order_id,\n    # ... other fields ...\n    metadata=metadata\n)\n</code></pre></p>"},{"location":"API/database.html#thread-safety-and-connection-pooling","title":"Thread Safety and Connection Pooling","text":"<p>The <code>DBHandler</code> is a thread-safe singleton with connection pooling:</p> <ul> <li>Singleton Pattern: Only one instance per application</li> <li>Connection Pool: Pre-created connections for efficiency (pool size: 10)</li> <li>Context Managers: Automatic connection lifecycle management</li> <li>Lock Protection: Thread-safe order ID generation</li> <li>WAL Mode: Write-Ahead Logging for better concurrency</li> </ul> <p>Best Practices: - Always use <code>get_connection()</code> context manager for custom queries - Use the built-in methods for common operations - Don't hold connections longer than necessary - Connection pool automatically handles overflow with temporary connections</p>"},{"location":"API/email.html","title":"Sending email from Quantstrip","text":""},{"location":"API/email.html#the-send_email-function","title":"The <code>send_email()</code> function","text":"<p>send_email(subject,body,to,account=None)</p> <p>There are two ways to integrate with the email functionality in Quantstrip, either using the <code>send_email()</code> function or using the <code>email_manager</code> object for more advanced options and formatting. </p> <p>The <code>send_email()</code> function provides a simple interface for sending emails from your trading clients. It's part of the email management system that supports multiple email accounts and handles all SMTP configuration automatically.</p> <p>Key Features</p> <ul> <li>Simple function call to send emails</li> <li>Automatic account selection (uses default if not specified)</li> <li>Support for multiple recipients</li> <li>HTML email support</li> <li>Built-in error handling and reporting</li> </ul> <p>Parameters:</p> Parameter Type Description <code>subject</code> <code>str</code> Email subject line <code>body</code> <code>str</code> Email body content (plain text or HTML) <code>to</code> <code>str</code> Recipient email address(es), comma-separated for multiple <code>account</code> <code>str</code> Optional account name to use. Uses default account if not specified <p>Returns: <code>tuple[bool, str]</code> - (success status, message describing result)</p> <p>Example: <pre><code>from quantstrip import send_email\n\n# Send with default account\nsuccess, msg = send_email(\n    subject=\"Trade Alert\",\n    body=\"SPY position opened at $450\",\n    to=\"trader@example.com\"\n)\n\nif success:\n    print(\"Email sent successfully\")\nelse:\n    print(f\"Email failed: {msg}\")\n</code></pre></p>"},{"location":"API/email.html#multiple-recipients","title":"Multiple Recipients","text":"<p>You can send to multiple recipients by comma-separating email addresses.</p> <p>Example: <pre><code># Send to multiple recipients\nsend_email(\n    subject=\"Daily Report\",\n    body=\"Trading summary attached\",\n    to=\"trader1@example.com,trader2@example.com,manager@example.com\"\n)\n</code></pre></p>"},{"location":"API/email.html#using-specific-account","title":"Using Specific Account","text":"<p>If you have multiple email accounts configured (e.g., one for alerts, one for reports), specify which to use with the <code>account</code> parameter.</p> <p>Example: <pre><code># Send using specific account\nsend_email(\n    subject=\"URGENT: Stop Loss Hit\",\n    body=\"Position closed at -2%\",\n    to=\"trader@example.com\",\n    account=\"Alerts\"  # Use the \"Alerts\" account\n)\n</code></pre></p>"},{"location":"API/email.html#error-handling","title":"Error Handling","text":"<p>The function returns a tuple with success status and a descriptive message. Always check the result to handle failures gracefully.</p> <p>Example: <pre><code>success, msg = send_email(\n    subject=\"Trade Execution\",\n    body=\"Filled 100 AAPL @ $150\",\n    to=\"trader@example.com\"\n)\n\nif not success:\n    # Handle the error\n    logger.error(f\"Failed to send email: {msg}\")\n    # Possible errors:\n    # - \"Email account 'X' not found\"\n    # - \"No email accounts configured\"\n    # - \"Authentication failed - check username/password\"\n    # - \"Could not connect to SMTP server - check server/port\"\n</code></pre></p>"},{"location":"API/email.html#common-use-cases","title":"Common Use Cases","text":""},{"location":"API/email.html#trade-alerts","title":"Trade Alerts","text":"<pre><code># Alert on position entry\ndef on_entry(self, symbol, price, quantity):\n    send_email(\n        subject=f\"Position Opened: {symbol}\",\n        body=f\"Bought {quantity} shares of {symbol} at ${price}\",\n        to=\"trader@example.com\"\n    )\n</code></pre>"},{"location":"API/email.html#daily-reports","title":"Daily Reports","text":"<pre><code># Send end-of-day summary\ndef send_daily_report(self):\n    report = self.generate_report()  # Your report logic\n\n    send_email(\n        subject=f\"Daily Report - {datetime.now().strftime('%Y-%m-%d')}\",\n        body=report,\n        to=\"trader@example.com,manager@example.com\"\n    )\n</code></pre>"},{"location":"API/email.html#error-notifications","title":"Error Notifications","text":"<pre><code># Alert on strategy errors\ntry:\n    self.execute_strategy()\nexcept Exception as e:\n    send_email(\n        subject=\"Strategy Error!\",\n        body=f\"Error in {self.strategy_name}:\\n{str(e)}\",\n        to=\"trader@example.com\",\n        account=\"Alerts\"  # Use high-priority account\n    )\n</code></pre>"},{"location":"API/email.html#stop-loss-alerts","title":"Stop Loss Alerts","text":"<pre><code># Urgent notifications\ndef on_stop_loss(self, symbol, loss_amount):\n    send_email(\n        subject=f\"STOP LOSS: {symbol}\",\n        body=f\"Stop loss triggered on {symbol}. Loss: ${loss_amount:.2f}\",\n        to=\"trader@example.com\",\n        account=\"Alerts\"\n    )\n</code></pre>"},{"location":"API/email.html#using-the-email_manager-object","title":"Using the email_manager object","text":"<p>The <code>email_manager</code> object can be used directly for more advanced options like sending HTML formatted emails.</p>"},{"location":"API/email.html#sending-html-emails","title":"Sending HTML Emails","text":"<p>For HTML formatted emails, use the underlying <code>email_manager.send()</code> function with <code>html=True</code>.</p> <p>Example: <pre><code>from quantstrip import email_manager\n\nhtml_body = \"\"\"\n&lt;html&gt;\n&lt;body&gt;\n    &lt;h2&gt;Trade Summary&lt;/h2&gt;\n    &lt;p&gt;Today's P&amp;L: &lt;span style=\"color:green\"&gt;$1,234.56&lt;/span&gt;&lt;/p&gt;\n    &lt;ul&gt;\n        &lt;li&gt;AAPL: +$500&lt;/li&gt;\n        &lt;li&gt;MSFT: +$734.56&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nsuccess, msg = email_manager.send(\n    subject=\"Daily P&amp;L Report\",\n    body=html_body,\n    to=\"trader@example.com\",\n    html=True\n)\n</code></pre></p>"},{"location":"API/email.html#configuration","title":"Configuration","text":"<p>Before using <code>send_email()</code>, you need to configure at least one email account in your settings. Email accounts are managed through the <code>EmailManager</code> class and stored in the settings system.</p>"},{"location":"API/email.html#account-setup","title":"Account Setup","text":"<p>Email accounts are configured at: <code>/config/Notification/Email Accounts/[AccountName]/</code></p> <p>Each account requires:</p> Field Description <code>smtp_server</code> SMTP server address (e.g., smtp.gmail.com) <code>smtp_port</code> SMTP port (typically 587 for TLS) <code>use_tls</code> Whether to use TLS encryption (true/false) <code>username</code> SMTP username <code>password</code> SMTP password (stored securely) <code>from_address</code> Email address to send from <code>from_name</code> Display name for sender <code>is_default</code> Whether this is the default account (true/false) <p>Provider Templates</p> <p>The <code>EmailManager</code> includes templates for common providers:</p> <ul> <li>Gmail: smtp.gmail.com:587 (requires App Password)</li> <li>Outlook: smtp.office365.com:587</li> <li>Yahoo: smtp.mail.yahoo.com:587 (requires App Password)</li> <li>SendGrid: smtp.sendgrid.net:587</li> </ul> <p>Use these templates when creating accounts programmatically.</p>"},{"location":"API/email.html#testing-configuration","title":"Testing Configuration","text":"<p>Always test your email configuration before relying on it in production. <pre><code>from email_manager import email_manager\n\n# Test an account\nsuccess, msg = email_manager.test_account(\n    name=\"Default\",\n    test_recipient=\"your.email@example.com\"\n)\n\nif success:\n    print(\"Email configuration working!\")\nelse:\n    print(f\"Configuration problem: {msg}\")\n</code></pre></p>"},{"location":"API/email.html#best-practices","title":"Best Practices","text":""},{"location":"API/email.html#batching-notifications","title":"Batching Notifications","text":"<p>Instead of sending an email for every event, batch them together. <pre><code>class NotificationBatcher:\n    def __init__(self, flush_interval_seconds=300):\n        self.messages = []\n        self.last_flush = datetime.now()\n        self.flush_interval = timedelta(seconds=flush_interval_seconds)\n\n    def add_message(self, message):\n        self.messages.append(f\"[{datetime.now().strftime('%H:%M:%S')}] {message}\")\n\n        # Auto-flush if interval passed\n        if datetime.now() - self.last_flush &gt; self.flush_interval:\n            self.flush()\n\n    def flush(self):\n        if self.messages:\n            body = \"\\n\".join(self.messages)\n            send_email(\n                subject=f\"Trading Updates ({len(self.messages)} events)\",\n                body=body,\n                to=\"trader@example.com\"\n            )\n            self.messages.clear()\n            self.last_flush = datetime.now()\n\n# Usage\nbatcher = NotificationBatcher(flush_interval_seconds=300)  # 5 minutes\n\n# Throughout trading day\nbatcher.add_message(\"Opened AAPL position\")\nbatcher.add_message(\"Stop loss adjusted for MSFT\")\n# ... messages accumulate ...\n\n# On shutdown or at regular intervals\nbatcher.flush()\n</code></pre></p>"},{"location":"API/email.html#troubleshooting","title":"Troubleshooting","text":"<p>Authentication Failed <pre><code>Error: \"Authentication failed - check username/password\"\n</code></pre> Solution: For Gmail/Yahoo, use App Passwords instead of account passwords. Enable 2FA first, then generate an app-specific password.</p> <p>Connection Errors <pre><code>Error: \"Could not connect to SMTP server - check server/port\"\n</code></pre> Solution: Verify your SMTP server and port. Most providers use port 587 with TLS.</p> <p>Account Not Found <pre><code>Error: \"Email account 'X' not found\"\n</code></pre> Solution: Check that the account name matches exactly (case-sensitive). Use <code>email_manager.get_accounts()</code> to list available accounts.</p> <p>No Accounts Configured <pre><code>Error: \"No email accounts configured\"\n</code></pre> Solution: Create at least one email account before calling <code>send_email()</code>.</p>"},{"location":"API/email.html#debugging","title":"Debugging","text":"<p>Enable detailed logging to troubleshoot email issues: <pre><code>import logging\n\n# Enable email manager debug logging\nlogging.getLogger('email_manager').setLevel(logging.DEBUG)\n\n# Your code\nsuccess, msg = send_email(\"Test\", \"Body\", \"test@example.com\")\nprint(f\"Result: {success}, Message: {msg}\")\n</code></pre></p>"},{"location":"API/logging.html","title":"Logging System","text":""},{"location":"API/logging.html#overview","title":"Overview","text":"<p>The Quantstrip logging system provides centralized, thread-safe logging for all application components. It automatically handles log rotation, console output, and separate error tracking for the web interface.</p> <p>Key Features</p> <ul> <li>Automatic daily log rotation with 30-day retention</li> <li>Thread-aware logging (tracks which thread generated each log)</li> <li>Separate error logs for web interface issues</li> <li>Console output for real-time monitoring</li> <li>Simulation console buffer for web IDE</li> <li>Singleton pattern ensures consistent logging across application</li> </ul>"},{"location":"API/logging.html#using-the-logger","title":"Using the Logger","text":""},{"location":"API/logging.html#basic-setup","title":"Basic Setup","text":"<p>The logger is automatically initialized when you import it. Simply get a logger instance for your module: <pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\n# Now you can log messages\nlogger.info(\"Strategy initialized\")\nlogger.warning(\"Low liquidity detected\")\nlogger.error(\"Order failed\")\n</code></pre></p>"},{"location":"API/logging.html#log-levels","title":"Log Levels","text":"<p>The logger supports standard Python logging levels:</p> Level When to Use Example <code>DEBUG</code> Detailed diagnostic information Variable values, state transitions <code>INFO</code> General informational messages Trade executions, strategy signals <code>WARNING</code> Warning messages for unexpected situations Missing data, API rate limits <code>ERROR</code> Error messages for failures Order rejections, connection failures <code>CRITICAL</code> Critical failures requiring immediate attention Database corruption, system crashes <p>Example: <pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\n# Different log levels\nlogger.debug(f\"Calculating signal with price={price}, volume={volume}\")\nlogger.info(f\"Generated BUY signal for {symbol}\")\nlogger.warning(f\"Spread wider than expected: {spread:.4f}\")\nlogger.error(f\"Failed to place order: {error_msg}\")\nlogger.critical(f\"Database connection lost!\")\n</code></pre></p>"},{"location":"API/logging.html#logging-in-trading-clients","title":"Logging in Trading Clients","text":"<p>Here's how to use logging in your custom trading clients: <pre><code>import logging\nfrom base_client import BaseClient\n\nlogger = logging.getLogger(__name__)\n\nclass Client(BaseClient):\n    def __init__(self):\n        super().__init__()\n        logger.info(\"Client initialized\")\n\n    def on_bar(self, symbol, bar):\n        logger.debug(f\"Processing bar for {symbol}: close={bar.close}\")\n\n        # Your strategy logic\n        if self.should_buy(bar):\n            logger.info(f\"BUY signal generated for {symbol} at {bar.close}\")\n            self.place_order(symbol, 100, \"BUY\")\n\n    def on_order_filled(self, order):\n        logger.info(f\"Order filled: {order.symbol} {order.side} \"\n                   f\"{order.quantity}@{order.fill_price}\")\n\n    def on_error(self, error):\n        logger.error(f\"Error occurred: {error}\")\n</code></pre></p>"},{"location":"API/logging.html#structured-logging","title":"Structured Logging","text":"<p>Use f-strings to create clear, structured log messages: <pre><code># Good - Clear and structured\nlogger.info(f\"Position opened: symbol={symbol}, qty={qty}, price={price:.2f}\")\n\n# Good - Include context\nlogger.warning(f\"Order retry {attempt}/{max_attempts} for {symbol}\")\n\n# Bad - Vague message\nlogger.info(\"Something happened\")\n\n# Bad - Missing context\nlogger.error(\"Failed\")\n</code></pre></p>"},{"location":"API/logging.html#logging-exceptions","title":"Logging Exceptions","text":"<p>Always log the full exception traceback for debugging: <pre><code>import logging\nimport traceback\n\nlogger = logging.getLogger(__name__)\n\ntry:\n    result = risky_operation()\nexcept Exception as e:\n    # Log with traceback\n    logger.error(f\"Operation failed: {e}\")\n    logger.error(traceback.format_exc())\n\n    # Or use exception() method for automatic traceback\n    logger.exception(f\"Operation failed for {symbol}\")\n</code></pre></p>"},{"location":"API/logging.html#logger-output-format","title":"Logger Output Format","text":"<p>Logs are automatically formatted with: - Timestamp (YYYY-MM-DD HH:MM:SS) - Log level (INFO, WARNING, ERROR, etc.) - Module name - Thread name - Message</p> <p>Example output: <pre><code>2025-01-17 14:30:45 - INFO - my_strategy - MainThread - Strategy initialized\n2025-01-17 14:30:46 - INFO - my_strategy - MainThread - BUY signal for AAPL at 150.25\n2025-01-17 14:30:47 - WARNING - my_strategy - MainThread - API rate limit approaching\n2025-01-17 14:30:48 - ERROR - my_strategy - MainThread - Order rejected: Insufficient funds\n</code></pre></p>"},{"location":"API/logging.html#log-files","title":"Log Files","text":""},{"location":"API/logging.html#service-log","title":"Service Log","text":"<p>Main application log with all system messages.</p> <ul> <li>Location: <code>Data/logs/service.log</code></li> <li>Rotation: Daily at midnight</li> <li>Retention: 30 days</li> <li>Contents: All application logs (INFO and above)</li> </ul>"},{"location":"API/logging.html#dash-error-log","title":"Dash Error Log","text":"<p>Separate log for web interface errors.</p> <ul> <li>Location: <code>Data/logs/dash_errors.log</code></li> <li>Rotation: Daily at midnight</li> <li>Retention: 7 days</li> <li>Contents: Dash/Flask/Werkzeug errors only</li> </ul> <p>Tip</p> <p>If your web interface isn't working, check <code>dash_errors.log</code> first.</p>"},{"location":"API/logging.html#common-patterns","title":"Common Patterns","text":""},{"location":"API/logging.html#strategy-logging","title":"Strategy Logging","text":"<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\nclass Client(BaseClient):\n    def __init__(self):\n        super().__init__()\n        self.strategy_name = \"Momentum v2\"\n        logger.info(f\"Initialized {self.strategy_name}\")\n\n    def run_client(self):\n        logger.info(f\"Starting {self.strategy_name}\")\n\n        try:\n            self.connect()\n            self.subscribe_data()\n            self.main_loop()\n        except Exception as e:\n            logger.error(f\"{self.strategy_name} crashed: {e}\")\n            logger.exception(\"Full traceback:\")\n        finally:\n            logger.info(f\"Shutting down {self.strategy_name}\")\n            self.cleanup()\n</code></pre>"},{"location":"API/logging.html#trade-execution-logging","title":"Trade Execution Logging","text":"<pre><code>def place_order(self, symbol, quantity, side):\n    logger.info(f\"Placing {side} order: {quantity} {symbol}\")\n\n    try:\n        order_id = self.broker.submit_order(symbol, quantity, side)\n        logger.info(f\"Order submitted: ID={order_id}\")\n        return order_id\n    except Exception as e:\n        logger.error(f\"Order failed for {symbol}: {e}\")\n        logger.exception(\"Order failure details:\")\n        return None\n\ndef on_order_filled(self, execution):\n    logger.info(\n        f\"FILL: {execution.side} {execution.shares} {execution.symbol} \"\n        f\"@ ${execution.price:.2f} (Order ID: {execution.order_id})\"\n    )\n</code></pre>"},{"location":"API/logging.html#position-management-logging","title":"Position Management Logging","text":"<pre><code>def update_position(self, symbol, new_position):\n    old_position = self.positions.get(symbol, 0)\n\n    if new_position != old_position:\n        change = new_position - old_position\n        logger.info(\n            f\"Position change: {symbol} {old_position} -&gt; {new_position} \"\n            f\"({change:+d})\"\n        )\n\n        self.positions[symbol] = new_position\n\n        # Log position action\n        if old_position == 0:\n            logger.info(f\"OPENED position in {symbol}\")\n        elif new_position == 0:\n            logger.info(f\"CLOSED position in {symbol}\")\n        elif old_position * new_position &lt; 0:\n            logger.info(f\"REVERSED position in {symbol}\")\n</code></pre>"},{"location":"API/logging.html#data-feed-logging","title":"Data Feed Logging","text":"<pre><code>def on_bar(self, symbol, bar):\n    # Debug-level for frequent events\n    logger.debug(\n        f\"Bar: {symbol} O={bar.open:.2f} H={bar.high:.2f} \"\n        f\"L={bar.low:.2f} C={bar.close:.2f} V={bar.volume}\"\n    )\n\ndef on_connection_lost(self):\n    logger.warning(\"Market data connection lost, attempting reconnect...\")\n\ndef on_connection_restored(self):\n    logger.info(\"Market data connection restored\")\n</code></pre>"},{"location":"API/logging.html#error-recovery-logging","title":"Error Recovery Logging","text":"<pre><code>def execute_with_retry(self, operation, max_attempts=3):\n    for attempt in range(1, max_attempts + 1):\n        try:\n            logger.debug(f\"Attempt {attempt}/{max_attempts}: {operation}\")\n            result = operation()\n            logger.info(f\"Operation succeeded on attempt {attempt}\")\n            return result\n        except Exception as e:\n            logger.warning(\n                f\"Attempt {attempt}/{max_attempts} failed: {e}\"\n            )\n\n            if attempt == max_attempts:\n                logger.error(f\"All {max_attempts} attempts failed\")\n                logger.exception(\"Final failure details:\")\n                raise\n\n            time.sleep(2 ** attempt)  # Exponential backoff\n</code></pre>"},{"location":"API/logging.html#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>import time\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef monitor_performance(func):\n    \"\"\"Decorator to log function execution time\"\"\"\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        elapsed = time.time() - start\n\n        if elapsed &gt; 1.0:  # Warn if slow\n            logger.warning(\n                f\"{func.__name__} took {elapsed:.2f}s (slow!)\"\n            )\n        else:\n            logger.debug(\n                f\"{func.__name__} took {elapsed:.3f}s\"\n            )\n\n        return result\n    return wrapper\n\n@monitor_performance\ndef calculate_signals(self, data):\n    # Your calculation logic\n    pass\n</code></pre>"},{"location":"API/logging.html#best-practices","title":"Best Practices","text":""},{"location":"API/logging.html#dos","title":"Do's","text":"<p>\u2705 Use appropriate log levels <pre><code>logger.debug(\"Detailed variable state\")  # For debugging only\nlogger.info(\"Normal operations\")         # Standard events\nlogger.warning(\"Unexpected but handled\") # Warnings\nlogger.error(\"Operation failed\")         # Errors\n</code></pre></p> <p>\u2705 Include context in messages <pre><code>logger.info(f\"Order filled: {symbol} {qty}@{price} (ID: {order_id})\")\n</code></pre></p> <p>\u2705 Log exceptions with traceback <pre><code>logger.exception(\"Failed to process order\")\n</code></pre></p> <p>\u2705 Use module-level loggers <pre><code>logger = logging.getLogger(__name__)  # At module level\n</code></pre></p>"},{"location":"API/logging.html#donts","title":"Don'ts","text":"<p>\u274c Don't log sensitive information <pre><code># BAD - Exposes credentials\nlogger.info(f\"Connecting with password: {password}\")\n\n# GOOD - Mask sensitive data\nlogger.info(\"Connecting to broker\")\n</code></pre></p> <p>\u274c Don't log excessively in tight loops <pre><code># BAD - Logs every iteration\nfor i in range(1000000):\n    logger.info(f\"Processing {i}\")  # Creates huge logs!\n\n# GOOD - Log summary\nfor i in range(1000000):\n    process(i)\nlogger.info(f\"Processed 1,000,000 items\")\n</code></pre></p> <p>\u274c Don't use print() instead of logging <pre><code># BAD - Won't be captured in log files\nprint(\"Order placed\")\n\n# GOOD - Use logger\nlogger.info(\"Order placed\")\n</code></pre></p> <p>\u274c Don't create logger in init <pre><code># BAD\nclass Client:\n    def __init__(self):\n        self.logger = logging.getLogger(__name__)  # Creates new instance\n\n# GOOD\nlogger = logging.getLogger(__name__)  # Module-level\n\nclass Client:\n    def __init__(self):\n        logger.info(\"Initialized\")\n</code></pre></p>"},{"location":"API/logging.html#thread-safe-logging","title":"Thread-Safe Logging","text":"<p>The logging system is fully thread-safe. Each log message includes the thread name automatically: <pre><code>import threading\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef worker_task(task_id):\n    logger.info(f\"Task {task_id} started\")\n    # Do work...\n    logger.info(f\"Task {task_id} completed\")\n\n# Run multiple threads\nthreads = []\nfor i in range(5):\n    t = threading.Thread(target=worker_task, args=(i,))\n    t.start()\n    threads.append(t)\n\nfor t in threads:\n    t.join()\n</code></pre></p> <p>Output shows thread names: <pre><code>2025-01-17 14:30:45 - INFO - module - Thread-1 - Task 0 started\n2025-01-17 14:30:45 - INFO - module - Thread-2 - Task 1 started\n2025-01-17 14:30:46 - INFO - module - Thread-1 - Task 0 completed\n2025-01-17 14:30:46 - INFO - module - Thread-2 - Task 1 completed\n</code></pre></p>"},{"location":"API/logging.html#simulation-console","title":"Simulation Console","text":"<p>When running strategies in the web IDE, logs are captured in real-time and displayed in the console.</p> <p>The simulation console shows: - Logger output from <code>simulation_thread</code> - Print statements from your code - Errors and exceptions</p> <p>Example client with console output: <pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\nclass Client(BaseClient):\n    def run_client(self):\n        logger.info(\"Strategy starting...\")  # Appears in console\n        print(\"Loading data...\")             # Also appears in console\n\n        try:\n            self.execute_strategy()\n            logger.info(\"Strategy completed\")\n        except Exception as e:\n            logger.error(f\"Strategy failed: {e}\")  # Red in console\n</code></pre></p>"},{"location":"API/logging.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"API/logging.html#logs-not-appearing","title":"Logs Not Appearing","text":"<p>Check log level: <pre><code>import logging\n\n# Ensure logger level is set correctly\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)  # Will show DEBUG and above\n</code></pre></p> <p>Verify logger name: <pre><code># Use __name__ for automatic module naming\nlogger = logging.getLogger(__name__)\n\n# Or use explicit name\nlogger = logging.getLogger(\"my_strategy\")\n</code></pre></p>"},{"location":"API/logging.html#too-many-logs","title":"Too Many Logs","text":"<p>Reduce log level: <pre><code># Only show warnings and errors\nlogger.setLevel(logging.WARNING)\n</code></pre></p> <p>Add conditional logging: <pre><code># Only log every 100th iteration\nif iteration % 100 == 0:\n    logger.debug(f\"Progress: {iteration} iterations\")\n</code></pre></p>"},{"location":"API/logging.html#performance-impact","title":"Performance Impact","text":"<p>Logging has minimal performance impact, but be cautious in high-frequency scenarios: <pre><code># BAD - Logs every tick\ndef on_tick(self, tick):\n    logger.info(f\"Tick: {tick.price}\")  # Too frequent!\n\n# GOOD - Log aggregates\ndef on_tick(self, tick):\n    self.tick_count += 1\n    if self.tick_count % 1000 == 0:\n        logger.info(f\"Processed {self.tick_count} ticks\")\n</code></pre></p>"},{"location":"API/logging.html#log-file-locations","title":"Log File Locations","text":"<p>All log files are stored in the <code>Data/logs/</code> directory: <pre><code>Data/\n\u2514\u2500\u2500 logs/\n    \u251c\u2500\u2500 service.log              # Current main log\n    \u251c\u2500\u2500 service.log.2025-01-16   # Previous day's log\n    \u251c\u2500\u2500 service.log.2025-01-15   # 2 days ago\n    \u251c\u2500\u2500 ...\n    \u251c\u2500\u2500 dash_errors.log          # Current web errors\n    \u2514\u2500\u2500 dash_errors.log.2025-01-16\n</code></pre></p> <p>Log Retention</p> <ul> <li>Main logs are kept for 30 days</li> <li>Dash error logs are kept for 7 days</li> <li>Logs rotate automatically at midnight</li> </ul>"},{"location":"API/quantstrip.html","title":"Quantstrip API","text":"<p>The <code>quantstrip</code> module provides the primary interface for integrating client applications with core Quantstrip functionality.  </p> <p>By importing <code>quantstrip</code>, client implementations gain access to the <code>ClientBase</code> class, which serves as the required foundation for registering and running within the Quantstrip background service.</p> <p>In addition to <code>ClientBase</code>, the module exposes the following classes and functions:</p> <ul> <li><code>db_handler</code></li> <li><code>email_manager</code></li> <li><code>settings_manager</code></li> <li><code>logging</code></li> </ul>"},{"location":"API/settings.html","title":"Settings Manager","text":""},{"location":"API/settings.html#settings","title":"<code>settings</code>","text":"<p>The <code>settings</code> module provides a hierarchical configuration management system for the Quantstrip trading platform. It stores all application settings in a JSON file with support for typed values, encryption for sensitive data, and a path-based navigation system.</p> <p>Key Features</p> <ul> <li>Hierarchical folder structure for organizing settings</li> <li>Type-safe values (text, float, bool, list, dict, secret)</li> <li>Automatic encryption/decryption for sensitive data (secrets)</li> <li>Path-based navigation (e.g., <code>/config/Settings/Database/Host</code>)</li> <li>Locked folders to prevent accidental deletion</li> <li>JSON-based storage for easy inspection and backup</li> </ul>"},{"location":"API/settings.html#configuration-concept","title":"Configuration Concept","text":"<p>The settings system organizes configuration data in a tree structure similar to a file system:</p> <pre><code>config/\n\u251c\u2500\u2500 Settings/\n\u2502   \u251c\u2500\u2500 Database/\n\u2502   \u2502   \u251c\u2500\u2500 Host: \"localhost\"\n\u2502   \u2502   \u251c\u2500\u2500 Port: 5432\n\u2502   \u2502   \u2514\u2500\u2500 Password: (encrypted)\n\u2502   \u251c\u2500\u2500 Broker/\n\u2502   \u2502   \u251c\u2500\u2500 IBKR/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Host: \"127.0.0.1\"\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Port: 7497\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Client_ID: 1\n\u2502   \u2502   \u2514\u2500\u2500 Account: \"U1234567\"\n\u2502   \u2514\u2500\u2500 Notification/\n\u2502       \u2514\u2500\u2500 Email Accounts/\n\u2502           \u2514\u2500\u2500 Gmail Trading/\n\u2502               \u251c\u2500\u2500 SMTP_Server: \"smtp.gmail.com\"\n\u2502               \u251c\u2500\u2500 SMTP_Port: 587\n\u2502               \u2514\u2500\u2500 Password: (encrypted)\n</code></pre>"},{"location":"API/settings.html#setting-types","title":"Setting Types","text":"<p>Each setting has a <code>_type</code> that determines how its value is stored and parsed:</p> Type Description Example Use <code>text</code> String values (default) Hostnames, usernames, names <code>float</code> Floating point numbers Prices, percentages, ratios <code>bool</code> Boolean true/false Enable/disable flags <code>list</code> Array of values Multiple accounts, symbols <code>dict</code> Key-value pairs Complex configuration objects <code>secret</code> Encrypted strings Passwords, API keys, tokens"},{"location":"API/settings.html#internal-storage-format","title":"Internal Storage Format","text":"<p>Settings are stored internally as JSON objects with <code>_value</code> and <code>_type</code> fields:</p> <pre><code>{\n  \"config\": {\n    \"Settings\": {\n      \"Database\": {\n        \"Host\": {\n          \"_value\": \"localhost\",\n          \"_type\": \"text\"\n        },\n        \"Port\": {\n          \"_value\": 5432,\n          \"_type\": \"float\"\n        },\n        \"Password\": {\n          \"_value\": \"ZW5jcnlwdGVkX3N0cmluZw==\",\n          \"_type\": \"secret\"\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Automatic Type Handling</p> <p>When you use <code>get_by_path()</code>, the settings manager automatically:</p> <ul> <li>Decrypts <code>secret</code> type values</li> <li>Parses <code>float</code> values to numbers</li> <li>Converts <code>bool</code> values to Python booleans</li> <li>Returns <code>list</code> and <code>dict</code> as native Python types</li> </ul> <p>You don't need to handle encryption or type conversion manually.</p>"},{"location":"API/settings.html#initialization","title":"Initialization","text":"<p>Import <code>settings</code> from <code>quantstrip</code> <pre><code>from quantstrip import settings as config\n</code></pre></p> <p>The settings manager automatically creates a default configuration file if it doesn't exist at <code>/Data/config.json</code>.</p>"},{"location":"API/settings.html#core-methods","title":"Core Methods","text":""},{"location":"API/settings.html#reading-settings","title":"Reading Settings","text":"<p>get_by_path(path)</p> <p>Get a setting value by path. Automatically decrypts secrets and parses values according to their type.</p> <p>Parameters:</p> Parameter Type Description <code>path</code> <code>str</code> Path to setting (e.g., \"/config/Settings/Database/Host\") <p>Returns: Parsed value according to type, or <code>None</code> if not found</p> <p>Path Format</p> <ul> <li>Paths use forward slashes as separators: <code>/config/Settings/Database/Host</code></li> <li>The <code>/config</code> prefix is optional and will be added automatically if omitted</li> <li>Paths are case-sensitive and must match the actual folder/setting names</li> </ul> <p>Example: <pre><code># Get text value\nhost = config.get_by_path(\"/config/Settings/Database/Host\")\nprint(host)  # \"localhost\"\n\n# Get numeric value\nport = config.get_by_path(\"/config/Settings/Database/Port\")\nprint(port)  # 5432 (as float)\n\n# Get boolean value\nenabled = config.get_by_path(\"/config/Settings/Feature/Enabled\")\nprint(enabled)  # True or False\n\n# Get encrypted secret (automatically decrypted)\npassword = config.get_by_path(\"/config/Settings/Database/Password\")\nprint(password)  # \"my_secret_password\" (decrypted)\n\n# Get list value\naccounts = config.get_by_path(\"/config/Settings/Broker/Accounts\")\nprint(accounts)  # [\"U1234567\", \"U7654321\"]\n\n# Get dict value\nsmtp_config = config.get_by_path(\"/config/Settings/Email/SMTP\")\nprint(smtp_config)  # {\"server\": \"smtp.gmail.com\", \"port\": 587}\n\n# Path with 'config' prefix omitted (automatically added)\nhost = config.get_by_path(\"/Settings/Database/Host\")  # Same as above\n</code></pre></p>"},{"location":"API/settings.html#writing-settings","title":"Writing Settings","text":"<p>set_by_path(path, value, value_type=\"text\")</p> <p>Set a setting value by path. Automatically encrypts secrets and stores values with proper typing.</p> <p>Parameters:</p> Parameter Type Description <code>path</code> <code>str</code> Path to setting (e.g., \"/config/Settings/Database/Host\") <code>value</code> <code>Any</code> The value to store <code>value_type</code> <code>str</code> Type: \"text\", \"float\", \"bool\", \"list\", \"dict\", \"secret\" (default: \"text\") <p>Returns: None (saves to config file)</p> <p>Type Specification</p> <p>Always specify the correct <code>value_type</code> when setting values. The type determines how the value is stored and parsed when retrieved:</p> <ul> <li>Use <code>\"secret\"</code> for sensitive data (passwords, API keys)</li> <li>Use <code>\"float\"</code> for numeric values</li> <li>Use <code>\"bool\"</code> for true/false flags</li> <li>Use <code>\"list\"</code> for arrays</li> <li>Use <code>\"dict\"</code> for objects</li> <li>Use <code>\"text\"</code> for strings (default)</li> </ul> <p>Example: <pre><code># Set text value\nconfig.set_by_path(\n    \"/config/Settings/Database/Host\",\n    \"localhost\",\n    value_type=\"text\"\n)\n\n# Set numeric value\nconfig.set_by_path(\n    \"/config/Settings/Database/Port\",\n    5432,\n    value_type=\"float\"\n)\n\n# Set boolean value\nconfig.set_by_path(\n    \"/config/Settings/Feature/Enabled\",\n    True,\n    value_type=\"bool\"\n)\n\n# Set encrypted secret\nconfig.set_by_path(\n    \"/config/Settings/Database/Password\",\n    \"my_secret_password\",\n    value_type=\"secret\"  # Will be encrypted automatically\n)\n\n# Set list value\nconfig.set_by_path(\n    \"/config/Settings/Broker/Accounts\",\n    [\"U1234567\", \"U7654321\"],\n    value_type=\"list\"\n)\n\n# Set dict value\nconfig.set_by_path(\n    \"/config/Settings/Email/SMTP\",\n    {\"server\": \"smtp.gmail.com\", \"port\": 587},\n    value_type=\"dict\"\n)\n\n# Value type defaults to \"text\" if not specified\nconfig.set_by_path(\n    \"/config/Settings/Broker/Name\",\n    \"Interactive Brokers\"\n)\n</code></pre></p>"},{"location":"API/settings.html#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"API/settings.html#broker-configuration","title":"Broker Configuration","text":"<pre><code># Set up IBKR connection settings\nconfig.set_by_path(\"/Settings/Broker/IBKR/Host\", \"127.0.0.1\", \"text\")\nconfig.set_by_path(\"/Settings/Broker/IBKR/Port\", 7497, \"float\")\nconfig.set_by_path(\"/Settings/Broker/IBKR/Client_ID\", 1, \"float\")\nconfig.set_by_path(\"/Settings/Broker/IBKR/Account\", \"U1234567\", \"text\")\n\n# Read broker settings\nibkr_host = config.get_by_path(\"/Settings/Broker/IBKR/Host\")\nibkr_port = int(config.get_by_path(\"/Settings/Broker/IBKR/Port\"))\nclient_id = int(config.get_by_path(\"/Settings/Broker/IBKR/Client_ID\"))\naccount = config.get_by_path(\"/Settings/Broker/IBKR/Account\")\n\n# Connect to broker\nbroker.connect(ibkr_host, ibkr_port, client_id)\n</code></pre>"},{"location":"API/settings.html#email-configuration","title":"Email Configuration","text":"<pre><code># Set up email account with encrypted password\nconfig.set_by_path(\n    \"/Settings/Notification/Email/SMTP_Server\",\n    \"smtp.gmail.com\",\n    \"text\"\n)\nconfig.set_by_path(\n    \"/Settings/Notification/Email/SMTP_Port\",\n    587,\n    \"float\"\n)\nconfig.set_by_path(\n    \"/Settings/Notification/Email/Username\",\n    \"trading@gmail.com\",\n    \"text\"\n)\nconfig.set_by_path(\n    \"/Settings/Notification/Email/Password\",\n    \"my_app_password\",\n    \"secret\"  # Encrypted automatically\n)\nconfig.set_by_path(\n    \"/Settings/Notification/Email/Use_TLS\",\n    True,\n    \"bool\"\n)\n\n# Read email settings (password is automatically decrypted)\nsmtp_server = config.get_by_path(\"/Settings/Notification/Email/SMTP_Server\")\nsmtp_port = int(config.get_by_path(\"/Settings/Notification/Email/SMTP_Port\"))\nusername = config.get_by_path(\"/Settings/Notification/Email/Username\")\npassword = config.get_by_path(\"/Settings/Notification/Email/Password\")  # Decrypted\nuse_tls = config.get_by_path(\"/Settings/Notification/Email/Use_TLS\")\n\n# Use in email client\nimport smtplib\nserver = smtplib.SMTP(smtp_server, smtp_port)\nif use_tls:\n    server.starttls()\nserver.login(username, password)\n</code></pre>"},{"location":"API/settings.html#strategy-parameters","title":"Strategy Parameters","text":"<pre><code># Store strategy configuration\nconfig.set_by_path(\n    \"/Settings/Strategies/Momentum/Lookback_Period\",\n    20,\n    \"float\"\n)\nconfig.set_by_path(\n    \"/Settings/Strategies/Momentum/Entry_Threshold\",\n    0.02,\n    \"float\"\n)\nconfig.set_by_path(\n    \"/Settings/Strategies/Momentum/Symbols\",\n    [\"AAPL\", \"MSFT\", \"GOOGL\", \"AMZN\"],\n    \"list\"\n)\nconfig.set_by_path(\n    \"/Settings/Strategies/Momentum/Enabled\",\n    True,\n    \"bool\"\n)\nconfig.set_by_path(\n    \"/Settings/Strategies/Momentum/Risk_Params\",\n    {\n        \"max_position_size\": 1000,\n        \"stop_loss_pct\": 0.02,\n        \"take_profit_pct\": 0.05\n    },\n    \"dict\"\n)\n\n# Read strategy parameters\nlookback = int(config.get_by_path(\"/Settings/Strategies/Momentum/Lookback_Period\"))\nthreshold = config.get_by_path(\"/Settings/Strategies/Momentum/Entry_Threshold\")\nsymbols = config.get_by_path(\"/Settings/Strategies/Momentum/Symbols\")\nenabled = config.get_by_path(\"/Settings/Strategies/Momentum/Enabled\")\nrisk_params = config.get_by_path(\"/Settings/Strategies/Momentum/Risk_Params\")\n\n# Use in strategy\nif enabled:\n    for symbol in symbols:\n        if check_momentum(symbol, lookback) &gt; threshold:\n            position_size = min(1000, risk_params[\"max_position_size\"])\n            place_order(symbol, position_size)\n</code></pre>"},{"location":"API/settings.html#database-configuration","title":"Database Configuration","text":"<pre><code># Store database connection settings\nconfig.set_by_path(\"/Settings/Database/Host\", \"localhost\", \"text\")\nconfig.set_by_path(\"/Settings/Database/Port\", 5432, \"float\")\nconfig.set_by_path(\"/Settings/Database/Database\", \"trading_db\", \"text\")\nconfig.set_by_path(\"/Settings/Database/Username\", \"trader\", \"text\")\nconfig.set_by_path(\"/Settings/Database/Password\", \"secure_password\", \"secret\")\nconfig.set_by_path(\"/Settings/Database/Use_SSL\", True, \"bool\")\n\n# Read and use database settings\ndb_config = {\n    \"host\": config.get_by_path(\"/Settings/Database/Host\"),\n    \"port\": int(config.get_by_path(\"/Settings/Database/Port\")),\n    \"database\": config.get_by_path(\"/Settings/Database/Database\"),\n    \"user\": config.get_by_path(\"/Settings/Database/Username\"),\n    \"password\": config.get_by_path(\"/Settings/Database/Password\"),  # Decrypted\n    \"sslmode\": \"require\" if config.get_by_path(\"/Settings/Database/Use_SSL\") else \"disable\"\n}\n\n# Connect to database\nimport psycopg2\nconn = psycopg2.connect(**db_config)\n</code></pre>"},{"location":"API/settings.html#feature-flags","title":"Feature Flags","text":"<pre><code># Store feature flags\nconfig.set_by_path(\"/Settings/Features/Paper_Trading\", True, \"bool\")\nconfig.set_by_path(\"/Settings/Features/Email_Notifications\", True, \"bool\")\nconfig.set_by_path(\"/Settings/Features/Real_Time_Data\", False, \"bool\")\nconfig.set_by_path(\"/Settings/Features/Advanced_Orders\", True, \"bool\")\n\n# Use feature flags in application\nif config.get_by_path(\"/Settings/Features/Paper_Trading\"):\n    print(\"Running in paper trading mode\")\n    broker = PaperBroker()\nelse:\n    print(\"Running in live trading mode\")\n    broker = LiveBroker()\n\nif config.get_by_path(\"/Settings/Features/Email_Notifications\"):\n    send_notification(\"Trading session started\")\n\nif config.get_by_path(\"/Settings/Features/Advanced_Orders\"):\n    enable_bracket_orders()\n    enable_trailing_stops()\n</code></pre>"},{"location":"API/settings.html#multiple-trading-accounts","title":"Multiple Trading Accounts","text":"<pre><code># Store multiple account configurations\naccounts = {\n    \"primary\": {\n        \"account_id\": \"U1234567\",\n        \"broker\": \"IBKR\",\n        \"enabled\": True\n    },\n    \"secondary\": {\n        \"account_id\": \"U7654321\",\n        \"broker\": \"IBKR\",\n        \"enabled\": False\n    }\n}\n\nconfig.set_by_path(\"/Settings/Accounts\", accounts, \"dict\")\n\n# Read and use accounts\nall_accounts = config.get_by_path(\"/Settings/Accounts\")\nfor name, details in all_accounts.items():\n    if details[\"enabled\"]:\n        print(f\"Trading with {name}: {details['account_id']}\")\n        broker.connect(account=details[\"account_id\"])\n</code></pre>"},{"location":"API/settings.html#best-practices","title":"Best Practices","text":""},{"location":"API/settings.html#1-always-use-the-correct-type","title":"1. Always Use the Correct Type","text":"<pre><code># \u2713 GOOD - Correct types specified\nconfig.set_by_path(\"/Settings/Port\", 7497, \"float\")\nconfig.set_by_path(\"/Settings/Enabled\", True, \"bool\")\nconfig.set_by_path(\"/Settings/API_Key\", \"secret_key\", \"secret\")\n\n# \u2717 BAD - Wrong or missing types\nconfig.set_by_path(\"/Settings/Port\", 7497)  # Stored as text \"7497\"\nconfig.set_by_path(\"/Settings/Enabled\", \"true\")  # Stored as text, not bool\nconfig.set_by_path(\"/Settings/API_Key\", \"secret_key\")  # Not encrypted!\n</code></pre>"},{"location":"API/settings.html#2-validate-retrieved-values","title":"2. Validate Retrieved Values","text":"<pre><code># Get value with validation\nport = config.get_by_path(\"/Settings/Broker/Port\")\nif port is None:\n    port = 7497  # Default value\n    config.set_by_path(\"/Settings/Broker/Port\", port, \"float\")\n\n# Convert to appropriate Python type if needed\nport = int(port)  # Convert float to int for socket connection\n</code></pre>"},{"location":"API/settings.html#3-use-descriptive-path-names","title":"3. Use Descriptive Path Names","text":"<pre><code># \u2713 GOOD - Clear, descriptive paths\nconfig.set_by_path(\"/Settings/Broker/IBKR/Connection/Host\", \"127.0.0.1\", \"text\")\nconfig.set_by_path(\"/Settings/Strategies/Momentum/Entry_Threshold\", 0.02, \"float\")\nconfig.set_by_path(\"/Settings/Notification/Email/Daily_Report/Enabled\", True, \"bool\")\n\n# \u2717 BAD - Ambiguous paths\nconfig.set_by_path(\"/Settings/H\", \"127.0.0.1\", \"text\")\nconfig.set_by_path(\"/Settings/T\", 0.02, \"float\")\nconfig.set_by_path(\"/Settings/E\", True, \"bool\")\n</code></pre>"},{"location":"API/settings.html#4-group-related-settings","title":"4. Group Related Settings","text":"<pre><code># \u2713 GOOD - Organized by category\nconfig.set_by_path(\"/Settings/Broker/IBKR/Host\", \"127.0.0.1\", \"text\")\nconfig.set_by_path(\"/Settings/Broker/IBKR/Port\", 7497, \"float\")\nconfig.set_by_path(\"/Settings/Broker/IBKR/Client_ID\", 1, \"float\")\n\n# \u2717 BAD - Scattered settings\nconfig.set_by_path(\"/Settings/IBKR_Host\", \"127.0.0.1\", \"text\")\nconfig.set_by_path(\"/Settings/Port\", 7497, \"float\")\nconfig.set_by_path(\"/Settings/ID\", 1, \"float\")\n</code></pre>"},{"location":"API/settings.html#5-never-store-secrets-as-plain-text","title":"5. Never Store Secrets as Plain Text","text":"<pre><code># \u2713 GOOD - Secret type for sensitive data\nconfig.set_by_path(\n    \"/Settings/API/Key\",\n    \"sk_live_abc123xyz\",\n    \"secret\"  # Encrypted\n)\nconfig.set_by_path(\n    \"/Settings/Database/Password\",\n    \"my_password\",\n    \"secret\"  # Encrypted\n)\n\n# \u2717 BAD - Plain text secrets\nconfig.set_by_path(\n    \"/Settings/API/Key\",\n    \"sk_live_abc123xyz\",\n    \"text\"  # NOT encrypted!\n)\n</code></pre>"},{"location":"API/settings.html#security-considerations","title":"Security Considerations","text":"<p>Encryption Strength</p> <p>The built-in encryption uses simple base64 encoding with rotation. This provides basic obfuscation but is not cryptographically secure. For production systems with sensitive data:</p> <ul> <li>Consider implementing stronger encryption (e.g., using <code>cryptography</code> library)</li> <li>Store highly sensitive credentials in environment variables or a secrets manager</li> <li>Never commit the <code>config.json</code> file to version control</li> <li>Use proper file permissions to restrict access to the config file</li> </ul>"},{"location":"API/settings.html#recommended-production-setup","title":"Recommended Production Setup","text":"<pre><code>import os\n\n# For highly sensitive data, use environment variables\napi_key = os.environ.get(\"TRADING_API_KEY\")\n\n# Store in config only if not available in environment\nif api_key:\n    # Use environment variable\n    connect_to_api(api_key)\nelse:\n    # Fall back to encrypted config\n    api_key = config.get_by_path(\"/Settings/API/Key\")\n    connect_to_api(api_key)\n</code></pre>"},{"location":"API/settings.html#configuration-file-location","title":"Configuration File Location","text":"<p>The configuration file is stored at: <pre><code>/Data/config.json\n</code></pre></p> <p>This file is automatically created with default settings on first use. You can manually edit this file, but be careful to maintain the proper JSON structure with <code>_value</code> and <code>_type</code> fields for each setting.</p>"},{"location":"API/settings.html#example-manual-edit","title":"Example Manual Edit","text":"<pre><code>{\n  \"config\": {\n    \"Settings\": {\n      \"Broker\": {\n        \"IBKR\": {\n          \"Host\": {\n            \"_value\": \"127.0.0.1\",\n            \"_type\": \"text\"\n          },\n          \"Port\": {\n            \"_value\": 7497,\n            \"_type\": \"float\"\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Backup Configuration</p> <p>Regularly backup your <code>config.json</code> file, especially before making major changes. The file contains all your application settings and encrypted secrets.</p>"},{"location":"broker_integration/about_broker_integration.html","title":"About broker integration","text":"<p>The Quantstrip Trader does not include or support any broker connections. The reason behind this decision is that broker interfaces change frequently and new broker firms continuously enter the market, making it difficult to offer and maintain a growing set of high quality broker connections.</p> <p>Instead, we provide a set of implementation templates and Python code examples that can be used to integrate with both global and national broker services all over the world. Most of these brokers and trading venues provide high-level Python wrappers around their APIs which fits very well with the Quantstrip client architecture. Sometimes, there are unofficial Python APIs maintained by third parties and though we do provide examples including such APIs, we do not not encourage the use of any integration resources not officially issued by the broker firms themselves.  </p>"},{"location":"broker_integration/broker_integration_templates.html","title":"Broker integration templates","text":"<p>The AVANZA Python API is not an official integration and not supported by AVANZA. The information provided here is for educational purposes only.</p>"},{"location":"code_examples/IBKR_template.html","title":"Interactive Brokers","text":"<p>The following code examples for integrating with Interactive Brokers are included with Quantstrip. They can all be downloaded from the Script Templates section on the Quantstrip website.</p> <ul> <li><code>ib_connect.py</code></li> <li><code>ib_objects.py</code></li> <li><code>ib_send_order.py</code></li> </ul>"},{"location":"code_examples/IBKR_template.html#ib-api-vs-rest-api","title":"IB API vs REST API","text":"<p>Interactive Brokers offers two primary APIs for algorithmic trading and account management: the TWS API (also known as the IB API) and the REST API (Client Portal Web API).</p> <p>The TWS API is a socket-based interface that connects through either the Trader Workstation (TWS) desktop application or IB Gateway. It provides real-time streaming data, comprehensive order management, and access to historical market data. One of its key advantages is authentication persistence\u2014users only need to log in once per week, making it more convenient for automated trading systems that run continuously.</p> <p>The REST API (Client Portal Web API) is a modern, web-based interface that uses standard HTTP requests, making it easier to integrate with web applications and services that don't require constant connectivity. However, it requires daily authentication, as users must log in each trading day through the Client Portal gateway. This makes it less suitable for fully automated systems but more accessible for developers familiar with RESTful architecture.</p> <p>The choice between the two depends on the use case, but for continuously running trading applications the weekly authentication requirements of the TWS API makes it the better choice.</p>"},{"location":"code_examples/IBKR_template.html#synchronous-ib-api-wrapper","title":"Synchronous IB API Wrapper","text":"<p>The TWS API uses an asynchronous, callback-based design where requests and responses are decoupled\u2014you send a request through one method and receive the response later through a separate callback function. While this architecture is powerful for handling high-frequency, real-time data streams, it presents a steep learning curve for developers accustomed to synchronous programming patterns.</p> <p>For intraday trading strategies operating on a 5-10 minute timeframe where millisecond precision isn't critical, many developers find it beneficial to build a synchronous wrapper around the TWS API. This wrapper can convert the asynchronous callbacks into blocking function calls that wait for and return responses directly, making the code more intuitive and easier to reason about. The wrapper effectively bridges the gap between the API's event-driven architecture and traditional procedural code, simplifying strategy development while maintaining full access to the API's capabilities. For slower-paced trading strategies, the slight overhead introduced by this abstraction is negligible and the improved code clarity is well worth the trade-off.</p>"},{"location":"code_examples/IBKR_template.html#ib_connect","title":"<code>ib_connect</code>","text":"<p>This module provides a synchronous wrapper around Interactive Brokers' asynchronous Python API (ibapi). It uses threading events and thread-safe request IDs to convert IB's callback-based architecture into blocking <code>get_*</code> methods that wait for responses and return structured data. Each method manages its own event synchronization, making the API behave like traditional synchronous function calls while maintaining full access to IB's capabilities.</p>"},{"location":"code_examples/IBKR_template.html#connection-management","title":"Connection Management","text":"<p>connect_client(host=\"127.0.0.1\", port=7497, client_id=1)</p> <p>Connect to IB Gateway or TWS. Returns <code>True</code> if connected within 5 seconds, otherwise <code>False</code>.</p> <p>Parameters:</p> Parameter Type Description <code>host</code> <code>str</code> IB Gateway/TWS hostname (default: \"127.0.0.1\") <code>port</code> <code>int</code> API port (7497 for paper, 7496 for live) <code>client_id</code> <code>int</code> Unique client identifier <p>Returns: <code>bool</code></p> <p>Example: <pre><code>from IBKR.ib_connect import IB\n\nib = IB()\nif ib.connect_client(host=\"127.0.0.1\", port=7497, client_id=5):\n    print(\"Connected successfully\")\nelse:\n    print(\"Connection failed\")\n</code></pre></p> <p>Automatic Client ID Assignment</p> <p>The <code>ib_connect</code> module provides a client ID pool manager that automatically assigns an available ID to the connection unless specified as an argument. Once the connection closes, the ID is returned to the pool. This is convenient when many clients connect and disconnect at different times and eliminates the need to keep track of already connected IDs in the client code.</p> <p>NOTE: Clients collecting information from other clients, for example a centralized client keeping track of all executions, needs to connect with <code>client_id = 0</code> in order to receive callbacks originating from all other clients.</p> <p>disconnect_client()</p> <p>Disconnect from IB and clean up the socket thread.</p> <p>Example: <pre><code>ib.disconnect_client()\n</code></pre></p> <p>is_connected()</p> <p>Returns <code>True</code> if currently connected to IB.</p> <p>Returns: <code>bool</code></p> <p>Example: <pre><code>if ib.is_connected():\n    print(\"Still connected\")\n</code></pre></p> <p>get_client_id_stats()</p> <p>Get statistics about client ID usage from the connection pool.</p> <p>Returns: Dictionary with <code>'available'</code>, <code>'in_use'</code>, and <code>'total'</code> counts</p> <p>Example: <pre><code>stats = IB.get_client_id_stats()\nprint(f\"Available IDs: {stats['available']}\")\nprint(f\"In use: {stats['in_use']}\")\n</code></pre></p> <p>Using the Context Manager for Safe Connection Handling</p> <p>IB Gateway and TWS connections must be closed properly. To do this safely, careful exception handling is required to ensure that the connection is closed if the client job crashes. A convenient alternative to manage this is by using the context manager included in the IBKR template code.</p> <pre><code>from IBKR.ib_connect import IB\n\nwith IB() as ib:\n    df = ib.get_historical_data(...)\n    price = ib.get_last_price(...)\n# Connection automatically closed when exiting context\n</code></pre> <p>This syntax instantiates the <code>IB</code> class as the object <code>ib</code> and tries to connect to IB in a single line of code. By default it connects to the paper trading environment. To connect to the production environment instead, simply provide the production port number:</p> <pre><code>with IB(port=7496) as ib:  # Live trading port\n    # Your trading logic here\n</code></pre> <p>The context manager automatically: - Assigns a client ID from the pool (or uses one you specify) - Connects to IB Gateway/TWS - Releases the client ID back to the pool on exit - Handles cleanup even if exceptions occur</p>"},{"location":"code_examples/IBKR_template.html#market-data-methods","title":"Market Data Methods","text":"<p>get_historical_data(contract, endDateTime=\"\", durationStr=\"1 D\", barSizeSetting=\"1 min\", whatToShow=\"TRADES\", useRTH=1, formatDate=1, keepUpToDate=False, chartOptions=None, timeout=10.0)</p> <p>Request historical bars. Returns pandas DataFrame with columns: <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, <code>volume</code>, indexed by datetime. Returns empty DataFrame on timeout/error.</p> <p>Parameters:</p> Parameter Type Description <code>contract</code> <code>Contract</code> IB contract object <code>endDateTime</code> <code>str</code> End date/time (empty string = now) <code>durationStr</code> <code>str</code> Duration (e.g., \"1 D\", \"2 W\", \"1 M\") <code>barSizeSetting</code> <code>str</code> Bar size (e.g., \"1 min\", \"5 mins\", \"1 hour\") <code>whatToShow</code> <code>str</code> Data type (\"TRADES\", \"MIDPOINT\", \"BID\", \"ASK\") <code>useRTH</code> <code>int</code> 1 = regular trading hours only, 0 = all hours <code>formatDate</code> <code>int</code> 1 = yyyyMMdd HHss, 2 = Unix timestamp <code>keepUpToDate</code> <code>bool</code> Keep subscription active for updates <code>chartOptions</code> <code>List</code> Additional chart options <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>pandas.DataFrame</code></p> <p>Example: <pre><code>from ibapi.contract import Contract\n\ncontract = Contract()\ncontract.symbol = \"AAPL\"\ncontract.secType = \"STK\"\ncontract.exchange = \"SMART\"\ncontract.currency = \"USD\"\n\nwith IB() as ib:\n    df = ib.get_historical_data(\n        contract,\n        durationStr=\"5 D\",\n        barSizeSetting=\"1 hour\",\n        whatToShow=\"TRADES\"\n    )\n    print(df.head())\n</code></pre></p> <p>get_last_price(contract, timeout=5.0)</p> <p>Request market snapshot and return the most recent trade price as float. Returns <code>None</code> if unavailable.</p> <p>Parameters:</p> Parameter Type Description <code>contract</code> <code>Contract</code> IB contract object <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>Optional[float]</code></p> <p>Example: <pre><code>with IB() as ib:\n    price = ib.get_last_price(contract)\n    if price:\n        print(f\"Current price: ${price:.2f}\")\n    else:\n        print(\"Price not available\")\n</code></pre></p> <p>get_market_snapshot(contract, timeout=5.0)</p> <p>Request market snapshot. Returns dict with keys: <code>last</code>, <code>bid</code>, <code>ask</code>, <code>last_size</code>, <code>last_tick</code>. Returns empty dict on timeout.</p> <p>Parameters:</p> Parameter Type Description <code>contract</code> <code>Contract</code> IB contract object <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>Dict[str, Any]</code></p> <p>Example: <pre><code>with IB() as ib:\n    snapshot = ib.get_market_snapshot(contract)\n    print(f\"Last: {snapshot.get('last')}\")\n    print(f\"Bid: {snapshot.get('bid')}\")\n    print(f\"Ask: {snapshot.get('ask')}\")\n    print(f\"Last Size: {snapshot.get('last_size')}\")\n</code></pre></p> <p>get_realtime_bars(contract, whatToShow=\"TRADES\", useRTH=0, timeout=5.0)</p> <p>Request 5-second realtime bars. Returns DataFrame containing the first bar received with columns: <code>time</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, <code>volume</code>, <code>wap</code>, <code>count</code>. Returns empty DataFrame on timeout.</p> <p>Parameters:</p> Parameter Type Description <code>contract</code> <code>Contract</code> IB contract object <code>whatToShow</code> <code>str</code> Data type (\"TRADES\", \"MIDPOINT\", \"BID\", \"ASK\") <code>useRTH</code> <code>int</code> 1 = regular trading hours only, 0 = all hours <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>pandas.DataFrame</code></p> <p>Example: <pre><code>with IB() as ib:\n    bars = ib.get_realtime_bars(contract, whatToShow=\"TRADES\")\n    if not bars.empty:\n        print(f\"Latest bar: {bars.iloc[0]}\")\n</code></pre></p> <p>get_historical_ticks(contract, startDateTime=None, endDateTime=None, numberOfTicks=1000, whatToShow=\"TRADES\", useRth=1, timeout=10.0)</p> <p>Request historical tick data. Returns list of tick dicts. Returns empty list on timeout/error.</p> <p>Parameters:</p> Parameter Type Description <code>contract</code> <code>Contract</code> IB contract object <code>startDateTime</code> <code>str</code> Start date/time <code>endDateTime</code> <code>str</code> End date/time <code>numberOfTicks</code> <code>int</code> Maximum number of ticks to retrieve <code>whatToShow</code> <code>str</code> Tick type (\"TRADES\", \"BID_ASK\", \"MIDPOINT\") <code>useRth</code> <code>int</code> 1 = regular trading hours only, 0 = all hours <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>List[Dict[str, Any]]</code></p> <p>Example: <pre><code>with IB() as ib:\n    ticks = ib.get_historical_ticks(\n        contract,\n        numberOfTicks=100,\n        whatToShow=\"TRADES\"\n    )\n    print(f\"Received {len(ticks)} ticks\")\n</code></pre></p>"},{"location":"code_examples/IBKR_template.html#account-portfolio-methods","title":"Account &amp; Portfolio Methods","text":"<p>get_positions(timeout=10.0)</p> <p>Request current positions. Returns list of dicts with keys: <code>account</code>, <code>contract</code>, <code>position</code>, <code>avgCost</code>. Returns empty list on timeout/error.</p> <p>Parameters:</p> Parameter Type Description <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>List[Dict[str, Any]]</code></p> <p>Example: <pre><code>with IB() as ib:\n    positions = ib.get_positions()\n    for pos in positions:\n        contract = pos['contract']\n        print(f\"{contract['symbol']}: {pos['position']} @ ${pos['avgCost']:.2f}\")\n</code></pre></p> <p>get_portfolio(account=\"\", timeout=10.0)</p> <p>Subscribe briefly to account updates to obtain portfolio snapshot. Returns list of dicts with keys: <code>contract</code>, <code>position</code>, <code>marketPrice</code>, <code>marketValue</code>, <code>averageCost</code>, <code>unrealizedPNL</code>, <code>realizedPNL</code>, <code>accountName</code>. Returns empty list on timeout.</p> <p>Parameters:</p> Parameter Type Description <code>account</code> <code>str</code> Account identifier (empty = default) <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>List[Dict[str, Any]]</code></p> <p>Example: <pre><code>with IB() as ib:\n    portfolio = ib.get_portfolio()\n    for item in portfolio:\n        contract = item['contract']\n        print(f\"{contract['symbol']}: P&amp;L ${item['unrealizedPNL']:.2f}\")\n</code></pre></p> <p>get_account_summary(group=\"All\", tags=None, timeout=10.0)</p> <p>Request account summary values. Default tags: <code>NetLiquidation</code>, <code>TotalCashValue</code>, <code>AvailableFunds</code>, <code>BuyingPower</code>. Returns DataFrame with columns: <code>reqId</code>, <code>account</code>, <code>tag</code>, <code>value</code>, <code>currency</code>. Returns empty DataFrame on timeout/error.</p> <p>Parameters:</p> Parameter Type Description <code>group</code> <code>str</code> Account group (\"All\" for all accounts) <code>tags</code> <code>str</code> Comma-separated list of tags to retrieve <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>pandas.DataFrame</code></p> <p>Example: <pre><code>with IB() as ib:\n    summary = ib.get_account_summary()\n    for idx, row in summary.iterrows():\n        print(f\"{row['tag']}: {row['value']} {row['currency']}\")\n</code></pre></p>"},{"location":"code_examples/IBKR_template.html#order-methods","title":"Order Methods","text":"<p>get_next_order_id(timeout=5.0)</p> <p>Request the next valid order ID from IB. This is useful when you need to place orders and want to ensure you're using a valid order ID that won't conflict.</p> <p>Parameters:</p> Parameter Type Description <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>Optional[int]</code> - Next valid order ID, or None on timeout</p> <p>Example: <pre><code>with IB() as ib:\n    order_id = ib.get_next_order_id()\n    if order_id:\n        print(f\"Next order ID: {order_id}\")\n        # Use this ID when placing orders\n</code></pre></p> <p>get_executions(executionFilter=None, timeout=10.0)</p> <p>Request trade executions. Returns list of dicts containing order details with structure: <pre><code>{\n    'reqId': int,\n    'contract': {\n        'symbol': str,\n        'secType': str,\n        'exchange': str,\n        'currency': str,\n        'localSymbol': str,\n        'conId': int,\n        'primaryExchange': str\n    },\n    'execution': {\n        'orderId': int,\n        'clientId': int,\n        'execId': str,\n        'time': str,\n        'acctNumber': str,\n        'exchange': str,\n        'side': str,\n        'shares': float,\n        'price': float,\n        'permId': int,\n        'liquidation': int,\n        'cumQty': float,\n        'avgPrice': float,\n        'orderRef': str,\n        'evRule': str,\n        'evMultiplier': float,\n        'modelCode': str,\n        'lastLiquidity': int\n    }\n}\n</code></pre></p> <p>Parameters:</p> Parameter Type Description <code>executionFilter</code> <code>ExecutionFilter</code> Filter criteria (None = all executions) <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>List[Dict[str, Any]]</code></p> <p>Example: <pre><code>with IB() as ib:\n    executions = ib.get_executions()\n    for exec in executions:\n        contract = exec['contract']\n        execution = exec['execution']\n        print(f\"{contract['symbol']}: {execution['side']} {execution['shares']} @ ${execution['price']}\")\n</code></pre></p> <p>get_commissions(executionFilter=None, timeout=10.0)</p> <p>Request commission reports. Returns list of dicts with commission structure: <pre><code>{\n    'execId': str,\n    'commission': float,\n    'currency': str,\n    'realizedPNL': float,\n    'yield': float,\n    'yieldRedemptionDate': int\n}\n</code></pre></p> <p>Note: This calls <code>reqExecutions()</code> which triggers both <code>execDetails</code> and <code>commissionReport</code> callbacks, but only returns the commission data.</p> <p>Parameters:</p> Parameter Type Description <code>executionFilter</code> <code>ExecutionFilter</code> Filter criteria (None = all) <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>List[Dict[str, Any]]</code></p> <p>Example: <pre><code>with IB() as ib:\n    commissions = ib.get_commissions()\n    total_commission = sum(c['commission'] for c in commissions)\n    print(f\"Total commissions: ${total_commission:.2f}\")\n</code></pre></p> <p>get_open_orders(timeout=10.0)</p> <p>Request open orders for this client. Returns list of dicts with keys: <code>orderId</code>, <code>contract</code>, <code>order</code>, <code>orderState</code>. Returns empty list on timeout/error.</p> <p>Parameters:</p> Parameter Type Description <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>List[Dict[str, Any]]</code></p> <p>Example: <pre><code>with IB() as ib:\n    orders = ib.get_open_orders()\n    for order in orders:\n        contract = order['contract']\n        order_info = order['order']\n        state = order['orderState']\n        print(f\"Order {order['orderId']}: {contract['symbol']} \"\n              f\"{order_info['action']} {order_info['totalQuantity']} - {state['status']}\")\n</code></pre></p> <p>get_order_status(order_id, timeout=5.0)</p> <p>Retrieve latest known status for a specific order ID. Returns dict with status details or <code>None</code> if unknown.</p> <p>Parameters:</p> Parameter Type Description <code>order_id</code> <code>int</code> Order identifier <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>Optional[Dict[str, Any]]</code></p> <p>Example: <pre><code>with IB() as ib:\n    status = ib.get_order_status(order_id=12345)\n    if status:\n        print(f\"Status: {status['status']}\")\n        print(f\"Filled: {status['filled']}\")\n        print(f\"Remaining: {status['remaining']}\")\n</code></pre></p>"},{"location":"code_examples/IBKR_template.html#contract-reference-data-methods","title":"Contract &amp; Reference Data Methods","text":"<p>get_contract_details(contract, timeout=10.0)</p> <p>Request detailed contract specifications. Returns list of dicts containing <code>contractDetails</code> objects. Returns empty list on timeout/error.</p> <p>Parameters:</p> Parameter Type Description <code>contract</code> <code>Contract</code> IB contract object <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>List[Dict[str, Any]]</code></p> <p>Example: <pre><code>with IB() as ib:\n    details = ib.get_contract_details(contract)\n    for item in details:\n        cd = item['contractDetails']\n        print(f\"Contract: {cd.contract.symbol}\")\n        print(f\"Long Name: {cd.longName}\")\n        print(f\"Min Tick: {cd.minTick}\")\n</code></pre></p> <p>get_fundamental_data(contract, reportType=\"ReportSnapshot\", timeout=10.0)</p> <p>Request fundamental data (XML/text format). Returns string data or <code>None</code> on timeout/error.</p> <p>Parameters:</p> Parameter Type Description <code>contract</code> <code>Contract</code> IB contract object <code>reportType</code> <code>str</code> Report type (\"ReportSnapshot\", \"ReportsFinSummary\", etc.) <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>Optional[str]</code></p> <p>Example: <pre><code>with IB() as ib:\n    fundamentals = ib.get_fundamental_data(contract, reportType=\"ReportSnapshot\")\n    if fundamentals:\n        print(fundamentals[:500])  # Print first 500 chars\n</code></pre></p> <p>get_news_bulletins(timeout=5.0)</p> <p>Subscribe briefly to news bulletins. Returns list of bulletin dicts with keys: <code>msgId</code>, <code>msgType</code>, <code>message</code>, <code>exchange</code>. Best-effort; may return empty list.</p> <p>Parameters:</p> Parameter Type Description <code>timeout</code> <code>float</code> Timeout in seconds <p>Returns: <code>List[Dict[str, Any]]</code></p> <p>Example: <pre><code>with IB() as ib:\n    bulletins = ib.get_news_bulletins()\n    for bulletin in bulletins:\n        print(f\"{bulletin['msgType']}: {bulletin['message']}\")\n</code></pre></p>"},{"location":"code_examples/IBKR_template.html#complete-usage-example","title":"Complete Usage Example","text":"<pre><code>from IBKR.ib_connect import IB\nfrom ibapi.contract import Contract\n\n# Create contract\ncontract = Contract()\ncontract.symbol = \"AAPL\"\ncontract.secType = \"STK\"\ncontract.exchange = \"SMART\"\ncontract.currency = \"USD\"\n\n# Use as context manager\nwith IB() as ib:\n    # Get historical data\n    df = ib.get_historical_data(\n        contract,\n        durationStr=\"5 D\",\n        barSizeSetting=\"1 hour\"\n    )\n    print(f\"Retrieved {len(df)} bars\")\n\n    # Get current price\n    price = ib.get_last_price(contract)\n    print(f\"Current price: ${price:.2f}\")\n\n    # Get market snapshot\n    snapshot = ib.get_market_snapshot(contract)\n    print(f\"Bid: ${snapshot.get('bid'):.2f}, Ask: ${snapshot.get('ask'):.2f}\")\n\n    # Get positions\n    positions = ib.get_positions()\n    for pos in positions:\n        print(f\"Position: {pos['contract']['symbol']}, Qty: {pos['position']}\")\n\n    # Get account summary\n    summary = ib.get_account_summary()\n    for idx, row in summary.iterrows():\n        if row['tag'] == 'NetLiquidation':\n            print(f\"Net Liquidation: ${row['value']}\")\n\n    # Get executions\n    executions = ib.get_executions()\n    print(f\"Total executions: {len(executions)}\")\n\n# Connection automatically closed when exiting context\n</code></pre>"},{"location":"code_examples/IBKR_template.html#ib-objects","title":"IB Objects","text":"<p><code>ib_objects.py</code></p> <p>This module provides example factory functions to create Interactive Brokers API objects (Contracts and Orders) with sensible defaults for common trading scenarios. It has not been the ambition to wrap all available object types in the IB API, but rather to provide examples of how this can be done for contract and order objects.</p>"},{"location":"code_examples/IBKR_template.html#contract-function","title":"Contract Function","text":"<p>ib_contract(symbol)</p> <p>Creates an IB contract object for US stocks and ETFs. Extend this function with additional properties and logic or create additional ones for more advanced contracts.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> <code>str</code> Stock or ETF ticker symbol (e.g., \"AAPL\", \"SPY\") <p>Returns: <code>Contract</code></p> <p>Default Settings:</p> <ul> <li><code>currency</code>: \"USD\"</li> <li><code>exchange</code>: \"SMART\"</li> <li><code>secType</code>: \"STK\" (stock)</li> </ul> <p>Example: <pre><code>from IBKR.ib_objects import ib_contract\n\ncontract = ib_contract(\"SPY\")\n# Ready to use for market data or order placement\n\n# Contract can be customized further\ncontract.primaryExchange = \"ARCA\"\n</code></pre></p>"},{"location":"code_examples/IBKR_template.html#order-functions","title":"Order Functions","text":"<p>ib_order(quantity, order_ref='', orderType='MOC')</p> <p>Creates an example IB order object with automatic buy/sell direction based on quantity sign. Extend this function with additional properties and logic or create additional ones for more advanced order types.</p> <p>Parameters:</p> Parameter Type Description <code>quantity</code> <code>int</code> Order quantity (positive = BUY, negative = SELL) <code>order_ref</code> <code>str</code> Optional reference string for order tracking <code>orderType</code> <code>str</code> Order type (\"MOC\", \"MKT\", \"LMT\", etc.) <p>Returns: <code>Order</code></p> <p>Default Settings:</p> <ul> <li><code>action</code>: \"BUY\" or \"SELL\" (determined by quantity sign)</li> <li><code>totalQuantity</code>: Absolute value of quantity</li> <li><code>exchange</code>: \"SMART\"</li> <li><code>eTradeOnly</code>: False</li> <li><code>firmQuoteOnly</code>: False</li> </ul> <p>Example: <pre><code>from IBKR.ib_objects import ib_order\n\n# Market on close buy order\nbuy_order = ib_order(quantity=100, orderType=\"MOC\")\n\n# Market sell order with reference\nsell_order = ib_order(quantity=-50, order_ref=\"close_position\", orderType=\"MKT\")\n\n# Limit buy order (note: you'll need to set order.lmtPrice separately)\nlimit_order = ib_order(quantity=200, orderType=\"LMT\")\nlimit_order.lmtPrice = 150.00\n\n# Stop order\nstop_order = ib_order(quantity=-100, order_ref=\"stop_loss\", orderType=\"STP\")\nstop_order.auxPrice = 145.00  # Stop price\n</code></pre></p>"},{"location":"code_examples/IBKR_template.html#sending-an-order-to-ib","title":"Sending an Order to IB","text":"<p><code>ib_send_order.py</code></p> <p>This module contains a minimal test client demonstrating order placement through Interactive Brokers with database integration. This module shows a complete workflow: connecting to IB, placing an order, and recording the transaction in a database.</p> <p>Note: This is a reference implementation. Production usage requires proper error handling, connection management, and strategy configuration.</p>"},{"location":"code_examples/IBKR_template.html#client-class","title":"Client Class","text":"<p><code>Client(ClientBase)</code></p> <p>A test client that sends a single order to IB and records it in the database.</p> <p>Features:</p> <ul> <li>Inherits from <code>ClientBase</code> (Quantstrip framework)</li> <li>Connects to IB Gateway/TWS</li> <li>Places market order</li> <li>Records order in database</li> <li>Updates internal position tracking</li> <li>Automatically disconnects and stops after execution</li> </ul>"},{"location":"code_examples/IBKR_template.html#configuration","title":"Configuration","text":""},{"location":"code_examples/IBKR_template.html#default-settings","title":"Default Settings","text":"<pre><code>contract = ib_contract(\"SPY\")\norder = ib_order(quantity=100, orderType=\"MKT\")\n</code></pre> <ul> <li>Symbol: SPY (S&amp;P 500 ETF)</li> <li>Quantity: 100 shares (BUY)</li> <li>Order Type: Market order</li> <li>Client ID: 5 (for IB connection)</li> </ul>"},{"location":"code_examples/IBKR_template.html#workflow","title":"Workflow","text":"<p>The client executes the following sequence:</p> <ol> <li>Connect to IB: Establishes connection with <code>client_id=5</code></li> <li>Get Order ID: Retrieves next available order ID from database</li> <li>Place Order: Submits order to Interactive Brokers using <code>placeOrder()</code></li> <li>Record Order: Inserts order details into database orders table</li> <li>Update Position: Inserts strategy event into database</li> <li>Disconnect: Closes IB connection</li> <li>Stop Client: Terminates the client process</li> </ol>"},{"location":"code_examples/IBKR_template.html#database-integration","title":"Database Integration","text":""},{"location":"code_examples/IBKR_template.html#order-record","title":"Order Record","text":"<pre><code>db_handler.insert_order(\n    order_id=order_id,\n    strategy_id=1,      # Test Strategy\n    broker_id=1,        # IB broker\n    account=\"U1234567\",\n    symbol=\"SPY\",\n    side=\"BUY\",\n    order_type=\"MKT\",\n    total_quantity=100,\n    instrument_type=\"STK\",\n    client_reference=\"test_order\"\n)\n</code></pre>"},{"location":"code_examples/IBKR_template.html#strategy-event-record","title":"Strategy Event Record","text":"<pre><code>db_handler.insert_strategy_event(\n    order_id=order_id,\n    position=100,\n    event_type=\"OPEN\",\n    status=\"PENDING\",\n    metadata={\"source\": \"test_client\"}\n)\n</code></pre>"},{"location":"code_examples/IBKR_template.html#prerequisites","title":"Prerequisites","text":""},{"location":"code_examples/IBKR_template.html#database-setup","title":"Database Setup","text":"<p>A strategy must exist in the database strategy table before running: <pre><code>-- Example: Ensure strategy_id=1 exists\nINSERT INTO strategy (strategy_id, name, description)\nVALUES (1, 'Test Strategy', 'Testing order placement');\n</code></pre></p>"},{"location":"code_examples/IBKR_template.html#ib-connection","title":"IB Connection","text":"<ul> <li>IB Gateway or TWS must be running</li> <li>API connections must be enabled</li> <li>Default port: 7497 (paper trading) or 7496 (live)</li> </ul>"},{"location":"code_examples/IBKR_template.html#usage-example","title":"Usage Example","text":"<pre><code>from ib_send_order import Client\n\n# Initialize and run client\nclient = Client()\nclient.start()\n</code></pre> <p>Scheduler Behavior:</p> <ul> <li>Job runs once after 1 second</li> <li>Client automatically stops after execution</li> <li>Use for testing or one-time order placement</li> </ul>"},{"location":"code_examples/IBKR_template.html#customization","title":"Customization","text":""},{"location":"code_examples/IBKR_template.html#different-symbolquantity","title":"Different Symbol/Quantity","text":"<pre><code># At module level, before Client definition\ncontract = ib_contract(\"AAPL\")\norder = ib_order(quantity=-50, orderType=\"MKT\")  # Sell 50 shares\n</code></pre>"},{"location":"code_examples/IBKR_template.html#different-strategy","title":"Different Strategy","text":"<pre><code># In job() method\ndb_handler.insert_order(\n    order_id=order_id,\n    strategy_id=2,  # Change to your strategy ID\n    # ... rest of parameters\n)\n</code></pre>"},{"location":"code_examples/IBKR_template.html#continuous-operation","title":"Continuous Operation","text":"<pre><code>class Client(ClientBase):\n    def __init__(self, *args):\n        super().__init__()\n        # Run every hour instead of once\n        self.scheduler.every(1).hours.do(self.job)\n\n    def job(self):\n        # ... order placement logic ...\n        # Remove self.stop_client() to keep running\n</code></pre>"},{"location":"code_examples/IBKR_template.html#error-handling","title":"Error Handling","text":"<p>The client includes try-catch-finally structure:</p> <ul> <li>Try: Execute order placement and database operations</li> <li>Catch: Log errors with full traceback</li> <li>Finally: Always disconnect from IB (prevents connection leaks)</li> </ul> <pre><code>try:\n    # Order placement logic\nexcept Exception as e:\n    logger.info(f\"Error: {e}\")\n    logger.info(traceback.format_exc())\nfinally:\n    ib.disconnect_client()\n</code></pre>"},{"location":"code_examples/IBKR_template.html#important-notes","title":"Important Notes","text":"<p>Production Considerations</p> <ul> <li>This is a test/reference implementation</li> <li>Add proper validation and error recovery for production use</li> <li>Consider order status confirmation before database insertion</li> <li>Implement retry logic for connection failures</li> <li>Add position reconciliation checks</li> </ul> <p>Database Requirements</p> <ul> <li>`strategy_id=1</li> </ul>"},{"location":"code_examples/templates_general.html","title":"About examples","text":"<p>The fastest way to understand and learn how to develop quantstrip clients is to start with the templates available on www.quantstrip.com.</p>"},{"location":"dashboard_apps/SQL_database.html","title":"SQL Database","text":"<p>Quantstrip includes a pre-configured SQLite database to persist state data. The built-in SQL editor allows you to run report queries directly from the Dashboard app.</p> <p></p>"},{"location":"dashboard_apps/SQL_database.html#static-application-data","title":"Static application data","text":"<p>Static data objects, like Brokers and Strategies etc, can be managed directly from the Static Data tab.</p> <p></p>"},{"location":"dashboard_apps/backtrader.html","title":"Backtrader","text":""},{"location":"dashboard_apps/backtrader.html#future-integration-with-python-backtrader","title":"Future integration with Python Backtrader","text":""},{"location":"dashboard_apps/client_monitor.html","title":"Client Monitor","text":"<p>The Client Monitor provides a live updated view of all running clients and allows them to be stopped or started individually. If changes need to be made to a client, these will take effect once the client is stopped and restarted. </p> <p></p>"},{"location":"dashboard_apps/client_monitor.html#load-errors","title":"Load errors","text":"<p>If a client fails to start it will be included in the Problems tab. This can be due to a syntax error, like an unmatched parenthesis or an indentation error, for instance. It can also happen if the <code>Client</code> class is missing or not correctly declared. A full stack-trace is provided to track the error. Once the problem is fixed, the client can be reloaded and then moves from the Problems table to the Running Clients.</p>"},{"location":"dashboard_apps/client_monitor.html#runtime-errors","title":"Runtime errors","text":"<p>If a runtime error occurs, like an unhandled division-by-zero for instance, it will not prevent the client from loading, but it will crash at some point while running. If this happens, the client will stop and the stack trace will be shown directly in the Running clients tab.  </p>"},{"location":"dashboard_apps/email.html","title":"Notifications","text":"<p>The Notifications app enables you to configure email accounts for sending automated reports, alerts, and notifications from your trading system. Multiple accounts can be added and configured for different purposes, such as separating operational alerts from daily reports or using different accounts for different trading strategies.</p> <p></p>"},{"location":"dashboard_apps/email.html#configuring-email-accounts","title":"Configuring Email Accounts","text":"<p>The application includes built-in templates for common email service providers (such as Gmail, Outlook, and Yahoo) as well as a generic SMTP configuration option for custom mail servers. This simplifies the setup process while providing flexibility for various email infrastructure requirements.</p>"},{"location":"dashboard_apps/email.html#setting-a-default-account","title":"Setting a Default Account","text":"<p>Designate one account as the default for system-wide notifications. The default account will be used automatically unless a specific account is explicitly specified in your client code. This allows you to streamline notification logic while maintaining the flexibility to route specific messages through different accounts when needed.</p>"},{"location":"dashboard_apps/email.html#testing-email-configuration","title":"Testing Email Configuration","text":"<p>Before deploying your notification setup to production, verify the configuration by sending a test email. This confirms that authentication credentials, server settings, and network connectivity are properly configured.</p> <p>Test Before Production</p> <p>Always send a test email after configuring a new account to catch configuration issues early.</p>"},{"location":"dashboard_apps/email.html#sending-email-from-client-code","title":"Sending Email from Client Code","text":"<p>To send emails from your Python client modules, use the <code>email_manager</code> module from the <code>quantstrip</code> API. This module provides a consistent interface for email delivery across all configured accounts.</p> <pre><code>from quantstrip import email_manager\n\n# Send using default account\nemail_manager.send(\n    to=\"recipient@example.com\",\n    subject=\"Trade Alert\",\n    body=\"Your message here\"\n)\n\n# Send using a specific account\nemail_manager.send(\n    to=\"recipient@example.com\",\n    subject=\"Trade Alert\",\n    body=\"Your message here\",\n    account=\"trading_alerts\"\n)\n</code></pre>"},{"location":"dashboard_apps/logging.html","title":"Logging","text":"<p>Quantstrip includes a custome logger with a rotating file handler that breaks at midnight (local time). Log files can be inspected directly in the Logging dashboard app.</p> <p></p>"},{"location":"dashboard_apps/python_editor.html","title":"Python Editor","text":"<p>The Quantstrip Dashboard includes an integrated Python editor for developing and simulating client modules. When you execute code in the built-in IDE, it loads as a simulated client module and runs exactly as it would in the production environment.</p> <p>The <code>ClientBase</code> class is required</p> <p>All code must implement the <code>ClientBase</code> class to execute properly. The editor does not support arbitrary Python scripts.</p> <p></p>"},{"location":"dashboard_apps/python_editor.html#development-workflow","title":"Development Workflow","text":""},{"location":"dashboard_apps/python_editor.html#creating-a-new-client-file","title":"Creating a New Client File","text":"<p>To implement a new client module, create a file in the <code>Test</code> folder.</p> <p></p>"},{"location":"dashboard_apps/python_editor.html#using-the-default-client-template","title":"Using the Default Client Template","text":"<ol> <li>Navigate to the <code>Examples</code> folder</li> <li>Open <code>default_client.py</code> and copy its contents</li> <li>Return to the <code>Test</code> folder and paste the code into your new file</li> <li>Customize the display name and configure the job schedule</li> <li>Implement your business logic in the <code>job()</code> function</li> </ol>"},{"location":"dashboard_apps/python_editor.html#running-simulations","title":"Running Simulations","text":"<p>Execute your code in simulation mode and verify correct operation by monitoring log messages in the terminal window.</p> <p>Logging Best Practices</p> <p>Use the <code>logger</code> object for output instead of <code>print()</code>. The <code>print()</code> function does not redirect to the terminal window.</p> <p></p>"},{"location":"dashboard_apps/python_editor.html#configuring-single-run-testing","title":"Configuring Single-Run Testing","text":"<p>For testing scenarios that require a single execution\u2014such as validating execution rules or confirming order placement\u2014configure the client to run once and exit:</p> <ol> <li>Set the schedule to execute every second (ensuring immediate execution on startup)</li> <li>Call <code>stop_client()</code> at the end of the <code>job()</code> function</li> </ol> <p>This configuration stops the client automatically after completing the job.</p> <p></p>"},{"location":"dashboard_apps/python_editor.html#deploying-to-production","title":"Deploying to Production","text":"<p>After completing simulation testing, the client is deployed by moving it to the root directory. Select the client module to deploy and click the <code>Deploy</code> button. A cog icon on the Python file indicator confirms that the background process has registered and is running the client.</p> <p></p> <p>Avoid manual copy</p> <p>Though it's possible to copy a client module and paste it in the root directory manually it is not recommended. If the client module already exists it will be overwritten with the new version but not reoladed in the run time environment. When using the <code>Deploy</code>button, the existing client will be removed first and there will be a short delay before the new version of the client is pasted. This triggers the bacground service to unload the existing module and load the new version to ensure that the updated client is prperly deployed in production.  </p>"},{"location":"dashboard_apps/python_editor.html#managing-pypi-packages","title":"Managing PyPI Packages","text":"<p>Feature in Development</p> <p>Package management functionality is currently under development. The embedded pip installer supports many packages but may not work with all dependencies due to Python packaging complexity.</p>"},{"location":"dashboard_apps/python_editor.html#installing-packages","title":"Installing Packages","text":"<p>Install packages directly from the Python editor:</p> <ol> <li>Expand the INSTALL NEW PACKAGE section</li> <li>Enter the package name</li> <li>Click Install</li> </ol> <p></p>"},{"location":"dashboard_apps/python_editor.html#package-loading-considerations","title":"Package Loading Considerations","text":"<p>Most packages load immediately after installation. However, some packages (such as <code>yfinance</code>) have dependencies with native C extensions or components that register at the C level or with <code>atexit</code>. These dependencies may conflict with the running Python interpreter.</p> <p>Service Restart May Be Required</p> <p>If a package fails to load after installation, restart the background service to resolve conflicts.</p>"},{"location":"dashboard_apps/python_editor.html#package-management-notes","title":"Package Management Notes","text":"<p>Direct use of <code>pip</code> is not recommended. Quantstrip runs as a frozen installation in a virtual environment, which overrides the default package location in <code>/Lib/site-packages/</code>.</p>"},{"location":"dashboard_apps/reporting.html","title":"Reporting","text":""},{"location":"dashboard_apps/reporting.html#create-and-distribute-formatted-reports","title":"Create and distribute formatted reports","text":"<p>Use SQL to extract reports from the database and format them into nice looking reports or export to Excel.</p> <p>Distribute with the <code>Emailer</code></p>"},{"location":"dashboard_apps/settings.html","title":"Settings","text":"<p>The Settings app provides centralized storage and management for user-defined parameters. Settings can be organized in a hierarchical tree structure, allowing you to scale your configuration as your library of trading strategies and client applications grows.</p> <p></p>"},{"location":"dashboard_apps/settings.html#retrieving-settings-in-python","title":"Retrieving Settings in Python","text":"<p>To access settings from within client code, use the <code>settings_manager</code> module from the <code>quantstrip</code> API.</p>"},{"location":"dashboard_apps/settings.html#settings-vs-database-objects","title":"Settings vs Database Objects","text":"<p>Understanding the Distinction</p> <p>The Settings app is designed for flexible, evolving configuration data that may change over time as your system develops. In contrast, the database object model is built around the system's core order and post-trade processing functionality, representing a stable structure that is not intended to change significantly over time.</p>"},{"location":"dashboard_apps/trade_journal.html","title":"Trade journal","text":""},{"location":"dashboard_apps/trade_journal.html#enter-trades-manually","title":"Enter trades manually","text":"<p>The trade journal allows you to manually enter trades to:</p> <ol> <li>Enter or exit positions in case of broker or client problems.</li> <li>Keep record of manual trading activities and include them in the consolidated reports inside Quantstrip </li> </ol>"},{"location":"getting_started/overview.html","title":"Overview","text":"<p>Quantstrip provides an execution platform for trading strategies and other long-running tasks on your local computer. </p> <p>The system has three main parts:</p> <ol> <li>A Background Service running 24/7 (subject to the uptime of the local computer)</li> <li>A browser Dashbord with a set of apps</li> <li>A group of user defined Clients</li> </ol> <pre><code>graph TD\n    Dashboard[\"Dashboard\"]\n    BackgroundService[\"Background Service\"]\n    Client1[\"Client 1\"]\n    Client2[\"Client 2\"]\n    Client3[\"Client 3\"]\n    Client4[\"Client ...\"]\n    Client5[\"Client n\"]\n    Dashboard &lt;--&gt; BackgroundService\n    BackgroundService --&gt; Client1\n    BackgroundService --&gt; Client2\n    BackgroundService --&gt; Client3\n    BackgroundService --&gt; Client4\n    BackgroundService --&gt; Client5\n</code></pre>"},{"location":"getting_started/overview.html#the-background-service","title":"The Background Service","text":"<p>The background process is a continuously running process that manages the connected clients. When installed on a local machine, the background process is set up as a scheduled task that starts on system startup. If the system restarts, the background process also restarts automatically but it is generally recommended that you configure your operating system so system restarts only take place outside active business hours. </p> <p>The Quantstrip background services can be stopped and started manually in the Windows Service Manager.</p> <p></p>"},{"location":"getting_started/overview.html#the-dashboard","title":"The Dashboard","text":"<p>When the Background Service starts, it launches a local web server and a Dashboard page on <code>http://127.0.0.1:8051</code>. From the Dashboard you can reach a set of apps to configure and manage the system.</p> <p></p>"},{"location":"getting_started/overview.html#clients","title":"Clients","text":"<p>The connected clients contain the business logic for all the tasks managed by the system, like running a trading strategy or some other recurring job. </p> <p></p> <p>Clients are Python objects and to qualify as a Quantstrip client, each client object needs to implement the <code>ClientBase</code> base class that is part of the <code>quantstrip</code> API.</p> <p>Design patterns and code examples are provided for a number of common client tasks. Below is an example of a minimal client that can be implemented with only 10 lines of Python code:</p> my_client.py<pre><code>from quantstrip import ClientBase\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass Client(ClientBase):\n    \"\"\" A minimal test client without broker connection.\n        This type of clients are used to do regular tasks \n        not related to trading, like end of day reporting etc.\n    \"\"\"\n    def __init__(self, *args):\n        super().__init__()\n        self.display_name = \"My Client\"\n        self.scheduler.every(5).seconds.do(self.job)\n\n    def job(self):\n        logger.info(\"Hello from My Client\")\n</code></pre>"},{"location":"getting_started/overview.html#datamodel","title":"Datamodel","text":"<p>The Quantstrip database provides a datamodel to capture the post-trade process.</p> <p></p>"}]}